<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2015.2 (Build 540U)" ts="2016-09-06 22:31:01">
<Class name="%Text.Russian">
<Description><![CDATA[
See <CLASS>%Text.Text</CLASS>
<p>
The <CLASS>%Text.Russian</CLASS> class implements the Russian language-specific lemmatization algorithm,
initializes the language-specific list of noise words and loads Russian morphological dictionary.
<p class=MsoNormal>© Н.А.Шестакова, 2007 </p>
]]></Description>
<Super>%Text.Text</Super>
<TimeChanged>63628,40410.843032</TimeChanged>
<TimeCreated>60696,37781.22329</TimeCreated>

<Parameter name="DEBUG">
<Description><![CDATA[
<PARAMETER>DEBUG</PARAMETER>  #2: включает запись несловарных лемм в ^CacheTempMorpho("PRE",словоформа)=лемма <BR> ]]></Description>
<Default>0</Default>
</Parameter>

<Parameter name="SOURCELANGUAGE">
<Default>ru</Default>
</Parameter>

<Parameter name="DICTIONARY">
<Default>9</Default>
</Parameter>

<Parameter name="NOISEWORDS100">
<Description>
Список шумовых слов (стоп-слов), наиболее часто встречающихся в языке, которые лишь "раздувают" индексы и практически ничего не дают при полнотекстовом поиске. Список взят с http://forum.searchengines.ru/showthread.php?postid=7670 и http://snowball.tartarus.org/algorithms/russian/stop.txt
и несколько модифицирован (добавлены словоформы). На сайте, рекомендованном в описании %Text.Text (http://www.ranks.nl/stopwords/), русский язык отсутствует.</Description>
<Default>а без будто бы быть в вдруг ведь весь во вот впрочем все всегда всего вы г где год да даже два для до должный ее ей если есть еще ж же за зачем здесь и из или им иногда их к каждый как какой ко когда который кто куда лет ли либо между многий много многое можно мой мочь мы на над надо наконец наш не нельзя несколько нет ни нибудь никак никогда ничто но ну о об один однако он она они оно опять от очень перед по под потом потому про раз разве с сам самый свой</Default>
</Parameter>

<Parameter name="NOISEWORDS200">
<Default>себя сегодня сейчас со совсем та так также таки такой там твой те теперь то тогда тоже только тот три ту тут тута ты у уж хороший хорошо хоть хотя чей через что чтоб чтобы чуть этот я</Default>
</Parameter>

<Parameter name="NGRAMLEN">
<Description><![CDATA[
Список шумовых слов (стоп-слов), наиболее часто встречающихся в языке, которые лишь "раздувают" индексы и практически ничего не дают при полнотекстовом поиске. Список взят с http://forum.searchengines.ru/showthread.php?postid=7670 и http://snowball.tartarus.org/algorithms/russian/stop.txt
и несколько модифицирован (добавлены словоформы). На сайте, рекомендованном в описании %Text.Text (http://www.ranks.nl/stopwords/), русский язык отсутствует.
Параметр сознательно установлен в 1, т.к. это открывает возможность поиска словосочетаний, которая теряется при NGRAMLEN>1. Поясню на примере: <br>
SELECT myDocument, myTitle, myPar FROM ft.doc where myDocument %CONTAINS ('челюстно-лицевого')<br>при NGRAMLEN=2 найдет все тексты, содержащие формы слов "челюстный" и "лицевой" в любых комбинациях,<br>
а при NGRAMLEN=1 - лишь те тексты, которые содержат словосочетания, состоящие из форм слов "челюстный" и "лицевой" (вне зависимости от наличия дефиса, который считается разделителем).<br>
Т.е., будут найдены тексты, содержащие "челюстно лицевой", "челюстно-лицевого" и т.д., но не "челюстной нерв лицевого отдела".<br>
Заметим, что возможность поиска всех комбинаций заданных слов по-прежнему сохраняется:<br>
SELECT myDocument, myTitle, myPar FROM ft.doc where myDocument %CONTAINSTERM ('челюстно','лицевого')<br>
При желании вы, конечно, можете задать NGRAMLEN=2, учтите только, что объем индексов при этом существенно возрастет (в разы).]]></Description>
<Default>1</Default>
</Parameter>

<Method name="stemWord">
<Description><![CDATA[
<METHOD>stemWord</METHOD> - метод лемматизации на основе словаря.
<br>На входе: 
<li>b – словоформа</li>
<br>На выходе:
<li>возвращаемое значение (а также параметр b) – лемма</li>
<li>lb - список ($list) всех возможных вариантов лемм, полученных в результате анализа словоформы b.</li>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&b:%String,&lb:%String]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
#; лемматизируем только кириллицу (возможно с дефисами)!
	if ($length(b)<..#MINWORDLEN) || ($translate(b,"абвгдежзийклмнопрстуфхцчшщъыьэюяё-")'="") set lb=$listbuild(b) quit b
	set lem=""
	set lb=""
	set k=$length(b) 
	set b=$translate(b, "ё", "е") ;меняем ё на е
	#; Проверяем наличие слова в словаре
	if $data(^Dict(b)) {
    	for {
    		set lem=$order(^Dict(b, lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($get(^Lemma(lem)))
    		}
		}	
	#; Обработка слов с дефисом
	elseif $length(b, "-")>1 {
		set:($data(^Dict($piece(b, "-", 1)_$piece(b, "-", 2, $length(b, "-"))))) b=..stemWord($piece(b, "-", 1)_$piece(b, "-", 2, $length(b, "-")), .lb)
		quit:(lb'="") b
		set lpart=..stemWord($piece(b, "-", 1), .lp)
		set rpart=..stemWord($piece(b, "-", 2, $length(b, "-")), .rp)
		for i=1:1:$listlength(lp) {
			for j=1:1:$listlength(rp) {
				set lb=lb_$listbuild($list(lp, i)_"-"_$list(rp, j))
				}			
			}
		}
	#; Если не оказалось в словаре, выполняем процедуру предсказания		
	else {	
		set lb=..Prediction(b) 			
		}
    #;set b=lb ; выдаём список лемм для данной словоформы
	set b=$list(lb, $listlength(lb)) ;выдаём последнюю лемму из списка
	quit b
]]></Implementation>
</Method>

<Method name="Prediction">
<Description>
Предсказание незнакомых слов</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&b:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set lb=..Normalword(b)
	if lb="" {
		set lem=""
		set k=$length(b)
		set sc=0 
		for i=2:1:k { ;отсекаем от слова пошагово по букве с начала
			if (i=k-1)&&(sc=0)&&(..ends(b, k, 2, "ой", .j)) {
				set lb=lb_$listbuild($extract(b, 1, j))
				set sc=1
				}
			if (i=k)&&(sc=0)&&(..ends(b, k, 1, "о", .j)) {
				set lb=lb_$listbuild(b)
				set sc=1
				}
			quit:(sc=1)
			set stemend=$extract(b, i-1, i-1)
			if ..cons(stemend)=1 {
				set cons="cons"
				}
			elseif ..cons(stemend)=0 {
				set cons="vow"
				}	
			set psfl=$extract(b, i, k)
			if $data(^Predict(cons, psfl))=10 {
				for {
					set lem=$order(^Predict(cons, psfl, lem))
					quit:(lem="")
					set fl=$get(^Predict(cons, psfl, lem))
					if fl="#" {
						set fl=""
						}
					set lb=lb_$listbuild($extract(b, 1, i-1)_fl)
					}
				set sc=1					
				}
			}
		if (sc=0) { // окончание пустое! // &&(..ends(b, k, 0, "",.j)) {
			set lb=lb_$listbuild(b)
			}
		}
#if ..#DEBUG#2
	set ^CacheTempMorpho("PRE",b)=lb
#endif
    quit lb
]]></Implementation>
</Method>

<Method name="cons">
<Description>
Процедура проверки, является ли буква согласной</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>k</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	quit:("аеёиоуыэюяАЕЁИОУЫЭЮЯ#"[k) 0
	quit 1
]]></Implementation>
</Method>

<Method name="Normalword">
<Description>
Процедура проверки, имеет ли слово продуктивный префикс или продуктивный суффикс</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>b</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set lem=""
	set lb=""
	set k=$length(b)
	set j=""
	if (($extract(b, 1, 2)="не")||($extract(b, 1, 2)="ре")||($extract(b, 1, 2)="за")||($extract(b, 1, 2)="до")||($extract(b, 1, 2)="де")||($extract(b, 1, 2)="по"))&&(k'=2)&&(($data(^Dict($extract(b, 3, k))))) {
	    for {
    		set lem=$order(^Dict($extract(b, 3, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($extract(b, 1, 2)_$get(^Lemma(lem)))
    		}
    	set b=lb	
	    quit b
	}
	if (($extract(b, 1, 3)="суб")||($extract(b, 1, 3)="нео")||($extract(b, 1, 3)="без")||($extract(b, 1, 3)="меж")||($extract(b, 1, 3)="дез")||($extract(b, 1, 3)="пан")||($extract(b, 1, 3)="пра")||($extract(b, 1, 3)="все")||($extract(b, 1, 3)="вне")||($extract(b, 1, 3)="дис")||($extract(b, 1, 3)="бес")||($extract(b, 1, 3)="дву"))&&(k'=3)&&(($data(^Dict($extract(b, 4, k))))) {
	    for {
    		set lem=$order(^Dict($extract(b, 4, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($extract(b, 1, 3)_$get(^Lemma(lem)))
    		}
    	set b=lb	
	    quit b
	}
	if (($extract(b, 1, 4)="анти")||($extract(b, 1, 4)="обще")||($extract(b, 1, 4)="пост")||($extract(b, 1, 4)="пред")||($extract(b, 1, 4)="полу")||($extract(b, 1, 4)="пере")||($extract(b, 1, 4)="само")||($extract(b, 1, 4)="поли")||($extract(b, 1, 4)="одно")||($extract(b, 1, 4)="архи")||($extract(b, 1, 4)="пара")||($extract(b, 1, 4)="недо")||($extract(b, 1, 4)="мета")||($extract(b, 1, 4)="мало")||($extract(b, 1, 4)="мини")||($extract(b, 1, 4)="гипо")||($extract(b, 1, 4)="двух")||($extract(b, 1, 4)="грам")||($extract(b, 1, 4)="пери"))&&(k'=4)&&(($data(^Dict($extract(b, 5, k))))) {
	    for {
    		set lem=$order(^Dict($extract(b, 5, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($extract(b, 1, 4)_$get(^Lemma(lem)))
    		}
    	set b=lb
	    quit b
	}
	if (($extract(b, 1, 5)="после")||($extract(b, 1, 5)="небез")||($extract(b, 1, 5)="микро")||($extract(b, 1, 5)="контр")||($extract(b, 1, 5)="сверх")||($extract(b, 1, 5)="квази")||($extract(b, 1, 5)="супер")||($extract(b, 1, 5)="много")||($extract(b, 1, 5)="макро")||($extract(b, 1, 5)="гипер")||($extract(b, 1, 5)="разно")||($extract(b, 1, 5)="около")||($extract(b, 1, 5)="низко")||($extract(b, 1, 5)="интер"))&&(k'=5)&&(($data(^Dict($extract(b, 6, k))))) {
	    for {
    		set lem=$order(^Dict($extract(b, 6, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($extract(b, 1, 5)_$get(^Lemma(lem)))
    		}
    	set b=lb
	    quit b
	}
	if (($extract(b,1,6)="псевдо")||($extract(b,1,6)="ультра")||($extract(b,1,6)="внутри")||($extract(b,1,6)="экстра")||($extract(b,1,6)="мульти")||($extract(b,1,6)="энтеро"))&&(k'=6)&&(($data(^Dict($extract(b, 7, k))))) {
	    for {
    		set lem=$order(^Dict($extract(b, 7, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($extract(b, 1, 6)_$get(^Lemma(lem)))
    		}
    	set b=lb
	    quit b
	}
	if ($extract(b,1,7)="противо")&&(k'=7)&&(($data(^Dict($extract(b, 8, k))))) {
		for {
    		set lem=$order(^Dict($extract(b, 8, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($extract(b, 1, 7)_$get(^Lemma(lem)))
    		}
    	set b=lb
	    quit b
	}
	if ..ends(b, k, 4, "ость", .j)||..ends(b, k, 4, "ости", .j)||..ends(b, k, 5, "остью", .j)||..ends(b, k, 5, "остей", .j)||..ends(b, k, 5, "остям", .j)||..ends(b, k, 6, "остями", .j)||..ends(b, k, 5, "остях", .j) {
		set b=lb_$listbuild($extract(b, 1, j)_"ость")
		quit b
	}
	if ..ends(b, k, 4, "тель", .j)||..ends(b, k, 4, "теля", .j)||..ends(b, k, 4, "телю", .j)||..ends(b, k, 5, "телем", .j)||..ends(b, k, 4, "теле", .j)||..ends(b, k, 4, "тели", .j)||..ends(b, k, 5, "телей", .j)||..ends(b, k, 5, "телям", .j)||..ends(b, k, 6, "телями", .j)||..ends(b, k, 5, "телях", .j) {
		set b=lb_$listbuild($extract(b, 1, j)_"тель")
		quit b
	}
	if ..ends(b, k, 4, "ство", .j)||..ends(b, k, 4, "ства", .j)||..ends(b, k, 4, "ству", .j)||..ends(b, k, 5, "ством", .j)||..ends(b, k, 4, "стве", .j)||..ends(b, k, 4, "ства", .j)||..ends(b, k, 3, "ств", .j)||..ends(b, k, 5, "ствам", .j)||..ends(b, k, 6, "ствами", .j)||..ends(b, k, 5, "ствах", .j) {
		set b=lb_$listbuild($extract(b, 1, j)_"ство")
		quit b
	}
	if ..ends(b, k, 2, "ий", .j)||..ends(b, k, 3, "ого", .j)||..ends(b, k, 3, "ому", .j)||..ends(b, k, 2, "им", .j)||..ends(b, k, 2, "ом", .j)||..ends(b, k, 2, "ое", .j)||..ends(b, k, 2, "ая", .j)||..ends(b, k, 2, "ой", .j)||..ends(b, k, 2, "ую", .j)||..ends(b, k, 2, "ие", .j)||..ends(b, k, 2, "их", .j)||..ends(b, k, 2, "им", .j)||..ends(b, k, 3, "ими", .j) {
		if ($extract(b, j)="к") {
		    set b=lb_$listbuild($extract(b, 1, j)_"ий")
		    quit b
		}
	}
	if ..ends(b, k, 2, "ий", .j)||..ends(b, k, 3, "его", .j)||..ends(b, k, 3, "ему", .j)||..ends(b, k, 2, "им", .j)||..ends(b, k, 2, "ем", .j)||..ends(b, k, 2, "ее", .j)||..ends(b, k, 2, "ая", .j)||..ends(b, k, 2, "ей", .j)||..ends(b, k, 2, "ую", .j)||..ends(b, k, 2, "ие", .j)||..ends(b, k, 2, "их", .j)||..ends(b, k, 2, "им", .j)||..ends(b, k, 3, "ими", .j) {
		if ($extract(b, j-1, j)="ющ")||($extract(b, j-1, j)="ящ")||($extract(b, j-1, j)="ущ")||($extract(b, j-1, j)="ащ") {
		    set b=lb_$listbuild($extract(b, 1, j)_"ий")
		    quit b
		}
	}
	if ..ends(b, k, 2, "ия", .j)||..ends(b, k, 2, "ии", .j)||..ends(b, k, 2, "ию", .j)||..ends(b, k, 3, "ией", .j)||..ends(b, k, 2, "ий", .j)||..ends(b, k, 3, "иям", .j)||..ends(b, k, 4, "иями", .j)||..ends(b, k, 3, "иях", .j)||..ends(b, k, 2, "ие", .j)||..ends(b, k, 3, "ием", .j) {
		if ($extract(b,j-2, j)="фоб")||($extract(b, j)="г")||($extract(b,j-1, j)="ид")||($extract(b, j)="з")||($extract(b, j)="к")||($extract(b,j-2, j)="фил")||($extract(b, j)="м")||($extract(b,j-2, j)="ман")||($extract(b,j-1, j)="оп")||($extract(b,j-5, j)="бактер")||($extract(b,j-3, j)="метр")||($extract(b,j-1, j)="ур")||($extract(b, j)="с")||($extract(b, j-2,j)="пат")||($extract(b,j-3, j)="дент")||($extract(b, j)="ф")||($extract(b, j)="х")||($extract(b, j)="ц") {
		    set b=lb_$listbuild($extract(b, 1, j)_"ия")
		    quit b
			}
		if ($extract(b,j-1, j)="ан")||($extract(b, j-1, j)="ен")||($extract(b, j-2, j)="ств") {
			set b=lb_$listbuild($extract(b, 1, j)_"ие")
			quit b
			}
		else {
			set b=lb_$listbuild($extract(b, 1, j)_"ия")
			quit b
		}
	}
	if ..ends(b, k, 1, "а", .j)||..ends(b, k, 2, "ом", .j)||..ends(b, k, 1, "е", .j)||..ends(b, k, 1, "ы", .j)||..ends(b, k, 2, "ов", .j)||..ends(b, k, 2, "ам", .j)||..ends(b, k, 3, "ами", .j)||..ends(b, k, 2, "ах", .j)||..ends(b, k, 2, "ой", .j)||..ends(b, k, 2, "ей", .j) {
		if ($extract(b, j-1, j)="ид")||($extract(b, j-1, j)="аз")||($extract(b, j-1, j)="ез")||($extract(b, j-1, j)="оз")||($extract(b, j-1, j)="ал")||($extract(b, j-1, j)="ил")||($extract(b, j-1, j)="ол")||($extract(b, j-2, j)="изм")||($extract(b, j-1, j)="ан")||($extract(b, j-1, j)="ен")||($extract(b, j-2, j)="ген")||($extract(b, j-1, j)="ин")||($extract(b, j-4, j)="штейн")||($extract(b, j-1, j)="он")||($extract(b, j-2, j)="сон")||($extract(b, j-3, j)="скоп")||($extract(b, j-1, j)="ер")||($extract(b, j-2, j)="тор")||($extract(b, j-1, j)="ат")||($extract(b, j-1, j)="ит")||($extract(b, j-2, j)="ист") {
		#;if ($e(b, j-1, j)="ид")||($e(b, j-1, j)="аз")||($e(b, j-1, j)="ёз")||($e(b, j-1, j)="ез")||($e(b, j-1, j)="оз")||($e(b, j-1, j)="ал")||($e(b, j-1, j)="ил")||($e(b, j-1, j)="ол")||($e(b, j-2, j)="изм")||($e(b, j-1, j)="ан")||($e(b, j-1, j)="ен")||($e(b, j-2, j)="ген")||($e(b, j-1, j)="ин")||($e(b, j-4, j)="штейн")||($e(b, j-1, j)="он")||($e(b, j-2, j)="сон")||($e(b, j-3, j)="скоп")||($e(b, j-1, j)="ер")||($e(b, j-1, j)="ёр")||($e(b, j-2, j)="тор")||($e(b, j-1, j)="ат")||($e(b, j-1, j)="ит")||($e(b, j-2, j)="ист") {
			set b=lb_$listbuild($extract(b, 1, j))
			quit b
		}
		if ($extract(b,j-1,j)="ом")||($extract(b,j-1,j)="ем")||($extract(b,j-2,j)="азм")||($extract(b, j-4, j)="грамм")||($extract(b,j-1,j)="иц") {
		#;if ($e(b,j-1,j)="ом")||($e(b,j-1,j)="ём")||($e(b,j-1,j)="ем")||($e(b,j-2,j)="азм")||($e(b, j-4, j)="грамм")||($e(b,j-1,j)="иц") {			
			set b=lb_$listbuild($extract(b, 1, j)_"а")
			quit b
		}
	}
	if ..ends(b, k, 1, "а", .j)||..ends(b, k, 2, "ом", .j)||..ends(b, k, 1, "е", .j)||..ends(b, k, 2, "ов", .j)||..ends(b, k, 2, "ам", .j)||..ends(b, k, 3, "ами", .j)||..ends(b, k, 2, "ах", .j)||..ends(b, k, 2, "ой", .j)||..ends(b, k, 2, "ей", .j)||..ends(b, k, 1, "и",.j) {
		if ($extract(b, j-2, j)="инг")||($extract(b, j-3, j)="берг")||($extract(b, j-1, j)="ик") {
			set b=lb_$listbuild($extract(b, 1, j))
			quit b
		}
	}
	if ..ends(b, k, 2, "ея", .j)||..ends(b, k, 2, "еи", .j)||..ends(b, k, 2, "ею", .j)||..ends(b, k, 3, "еей", .j)||..ends(b, k, 2, "ей", .j)||..ends(b, k, 3, "еям", .j)||..ends(b, k, 4, "еями", .j)||..ends(b, k, 3, "еях", .j)||..ends(b, k, 2, "ее", .j) {
		if ($extract(b, j)="р") {
		    set b=lb_$listbuild($extract(b, 1, j)_"ея")
		    quit b
		}
	}
	if ..ends(b, k, 2, "ый", .j)||..ends(b, k, 3, "ого", .j)||..ends(b, k, 3, "ому", .j)||..ends(b, k, 2, "ым", .j)||..ends(b, k, 2, "ом", .j)||..ends(b, k, 2, "ое", .j)||..ends(b, k, 2, "ая", .j)||..ends(b, k, 2, "ой", .j)||..ends(b, k, 2, "ую", .j)||..ends(b, k, 2, "ые", .j)||..ends(b, k, 2, "ых", .j)||..ends(b, k, 2, "ым", .j)||..ends(b, k, 3, "ыми", .j) {
		if ($extract(b, j-1,j)="ов")||($extract(b, j)="н")||($extract(b, j-2,j)="ист") {
		    set b=lb_$listbuild($extract(b, 1, j)_"ый")
		    quit b
		}
	}
	if ..ends(b, k, 1, "у", .j)||..ends(b, k, 0, "",.j) {
		if ($extract(b, j-2, j)="инг")||($extract(b, j-3, j)="берг")||($extract(b, j-1, j)="ид")||($extract(b, j-1, j)="аз")||($extract(b, j-1, j)="ез")||($extract(b, j-1, j)="оз")||($extract(b, j-1, j)="ик")||($extract(b, j-1, j)="ал")||($extract(b, j-1, j)="ил")||($extract(b, j-1, j)="ол")||($extract(b, j-2, j)="изм")||($extract(b, j-1, j)="ан")||($extract(b, j-1, j)="ен")||($extract(b, j-2, j)="ген")||($extract(b, j-1, j)="ин")||($extract(b, j-4, j)="штейн")||($extract(b, j-1, j)="он")||($extract(b, j-2, j)="сон")||($extract(b, j-3, j)="скоп")||($extract(b, j-1, j)="ер")||($extract(b, j-2, j)="тор")||($extract(b, j-1, j)="ат")||($extract(b, j-1, j)="ит")||($extract(b, j-2, j)="ист") {
		#;if ($e(b, j-2, j)="инг")||($e(b, j-3, j)="берг")||($e(b, j-1, j)="ид")||($e(b, j-1, j)="аз")||($e(b, j-1, j)="ёз")||($e(b, j-1, j)="ез")||($e(b, j-1, j)="оз")||($e(b, j-1, j)="ик")||($e(b, j-1, j)="ал")||($e(b, j-1, j)="ил")||($e(b, j-1, j)="ол")||($e(b, j-2, j)="изм")||($e(b, j-1, j)="ан")||($e(b, j-1, j)="ен")||($e(b, j-2, j)="ген")||($e(b, j-1, j)="ин")||($e(b, j-4, j)="штейн")||($e(b, j-1, j)="он")||($e(b, j-2, j)="сон")||($e(b, j-3, j)="скоп")||($e(b, j-1, j)="ер")||($e(b, j-1, j)="ёр")||($e(b, j-2, j)="тор")||($e(b, j-1, j)="ат")||($e(b, j-1, j)="ит")||($e(b, j-2, j)="ист") {
			set b=lb_$listbuild($extract(b, 1, j))
			quit b
		}
		if ($extract(b,j-1,j)="ом")||($extract(b,j-1,j)="ем")||($extract(b,j-2,j)="азм")||($extract(b, j-4, j)="грамм")||($extract(b,j-1,j)="иц") {
		#;if ($e(b,j-1,j)="ом")||($e(b,j-1,j)="ём")||($e(b,j-1,j)="ем")||($e(b,j-2,j)="азм")||($e(b, j-4, j)="грамм")||($e(b,j-1,j)="иц") {
			set b=lb_$listbuild($extract(b, 1, j)_"а")
			quit b
		}
	}			
	quit ""
]]></Implementation>
</Method>

<Method name="LoadDict">
<Description><![CDATA[
<METHOD>LoadDict</METHOD> - метод загрузки грамматического словаря из файла
<br>На входе:
<li>filename - полный путь к файлу словаря (http://www.aot.ru/download.php, Морф. словарь (русск.)) </li>
<br>На выходе:
<li>1 - успех, 0 - не удалось открыть файл.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	set sc=..readDictionary(filename, .number)
 	if sc=1 { 
 		do ..inflections(filename)
 		do ..dictionarize(number)
 	}
 	quit sc
]]></Implementation>
</Method>

<Method name="readDictionary">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[filename:%String,&number]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^CacheTempPdgm1
	kill ^CacheTempA1
	close filename
	open filename:("RK\CP1251\"):5 if '$test { quit 0 }
		use filename
		read stringnum
		for i=1:1:stringnum {
			read str
			set ^CacheTempPdgm1(i)=..formatstr2(str)
			}
		
		do {			
			read str
			} while '(str?6N) 
		if str?6N {
			set number=str	
			for i=1:1:number {
				read str
				set ^CacheTempA1(i)=..formatstr(str)
			}
		}
	close filename
	quit 1
]]></Implementation>
</Method>

<Method name="formatstr">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
 ;делаем из леммы список словоформ
	set string=$zconvert(string ,"L")
	set pdgm=$piece(string, " ",2)+1
	set plist=^CacheTempPdgm1(pdgm)
	set l=$listlength(plist) ;отбрасываем #
	for j=1:1:l {
		set $list(lstring, j)=$piece(string, " ",1) _ $list(plist, j)
		if ($extract($list(lstring, j))="#")&&($extract($list(lstring, j), 2)'="") { 
		set k=$list(lstring, j) 
		set $extract(k)=""
		set $list(lstring, j)=k 
		}
		}
	quit lstring
]]></Implementation>
</Method>

<Method name="formatstr2">
<ClassMethod>1</ClassMethod>
<FormalSpec>string</FormalSpec>
<Private>1</Private>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
 ; строку парадигмы приводим к списку окончаний
	set string=$zconvert(string ,"L")
	set lstring=$length(string, "*")
	set paradigm=""
	for j=1:1:lstring {
		if $find($piece(string, "*", j), "%")'=0 {
			set paradigm=paradigm_$listbuild($piece($piece(string, "*", j), "%", 2))
		}
		
		}
	quit paradigm
]]></Implementation>
</Method>

<Method name="dictionarize">
<ClassMethod>1</ClassMethod>
<FormalSpec>number</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
 ;все слова в своём глобале, словоформы в своём, 
 ;С УЧЁТОМ ГРАММАТИЧЕСКОЙ НЕОДНОЗНАЧНОСТИ.
	kill ^Lemma
	kill ^Dict
	if ($sortbegin(^Lemma)) {}
	if ($sortbegin(^Dict)) {}
	for i=1:1:number {
		set wlist=^CacheTempA1(i)
		set ^Lemma(i)=$list(wlist, 1)
		set b=$listlength(wlist)
		for j=1:1:b {
			set ^Dict($translate($list(wlist, j), "ё","е"),i)=""
			}
	}
	if ($sortend(^Lemma)) {}
	if ($sortend(^Dict)) {}
	kill ^CacheTempPdgm1
	kill ^CacheTempA1
]]></Implementation>
</Method>

<Method name="inflections">
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
	kill ^Predict ;глобал для предсказания
	if ($sortbegin(^Predict)) {}
	close filename
	open filename:("RK\CP1251\")
		use filename
		do {			
			read str
			} while '(str?6N) 
		if str?6N {
			set number=str	
			for i=1:1:number {
				read str
				set stem=$piece(str, " ", 1)
				set l=$length(stem)
				set k=$piece(str, " ", 2)
				if ..cons($extract(stem, l))=1 {		
					if $data(a(k))=0 {
						set a(k)=1
						set array(i)=k
						set letter(k)="cons"
						}
					else {
						set b=$get(a(k))
						set a(k)=b+1
						if letter(k)="vow" {
							set letter(k)="letter"
							}
						}
					}
				elseif ..cons($extract(stem, l))=0 {		
					if $data(a(k))=0 {
						set a(k)=1
						set array(i)=k
						set letter(k)="vow"
						}
					else {
						set b=$get(a(k))
						set a(k)=b+1
						if letter(k)="cons" {
							set letter(k)="letter"
							}
						}
					}
				}
			}
	close filename
	for i=1:1:number {
		set m=$get(array(i))
		if $data(array(i))'=0, a(m)>247, letter(m)="cons"||"letter" {
			set plist=$get(^CacheTempPdgm1(m+1))
			set b=$listlength(plist)
			for j=1:1:b {
				if $list(plist, j)="" {
					set $list(plist, j)="#"
					}
				}			
			for j=1:1:b {
				set d=$list(plist, 1)
				set u=$list(plist, j)
				set t=""			
				for {
					set sc=0
					set t=$order(^Predict("cons", u, t))
					quit:(t="")
					if $get(^Predict("cons", u,t))=d, t<(a(m)) {
						set ^Predict("cons", u, a(m))=d
						kill ^Predict("cons", u,t)
						set sc=1
						quit
						}
					elseif $get(^Predict("cons", u,t))=d, t>=(a(m)) {
						set sc=1
						quit
						}
					}
				if sc=0 {
					set ^Predict("cons", u, a(m))=d
					}
				}
			}
		if $data(array(i))'=0, a(m)>247, letter(m)="vow"||"letter" {
			set plist=$get(^CacheTempPdgm1(m+1))
			set b=$listlength(plist)
			for j=1:1:b {
				if $list(plist, j)="" {
					set $list(plist, j)="#"
					}
				}			
			for j=1:1:b {
				set d=$list(plist, 1)
				set u=$list(plist, j)
				set t=""			
				for {
					set sc=0
					set t=$order(^Predict("vow", u, t))
					quit:(t="")
					if $get(^Predict("vow", u,t))=d, t<(a(m)) {
						set ^Predict("vow", u, a(m))=d
						kill ^Predict("vow", u,t)
						set sc=1
						quit
						}
					elseif $get(^Predict("vow", u,t))=d, t>=(a(m)) {
						set sc=1
						quit
						}
					}
				if sc=0 {
					set ^Predict("vow", u, a(m))=d
					}
				}
			}
 		}
	if ($sortend(^Predict)) {}
]]></Implementation>
</Method>
</Class>


<Project name="Project1" LastModified="2016-02-21 14:34:04.244887" HttpServer="http://localhost:57772">
  <Items>
    <ProjectItem name="%Text.Russian" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Data.Base.Entity" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Data.Config" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Data.CrawlingHistoryItem" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Data.RecipeData.NearestResult" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Data.RecipeData.RecipeCluster" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Data.RecipeData.WordsTF" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Data.SearchSettings" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Data.SitePage" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Data.SiteToCrawl" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Data.TfIdfConfig" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Data.Utils.Seed" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Logging.LogRecord" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.IdfBuild.Builder" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.IdfBuild.Implementations.Default" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.IdfBuild.Implementations.FilteredMax" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.IdfBuild.Implementations.FilteredOrdinary" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.IdfBuild.Implementations.FilteredSmooth" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.IdfBuild.Implementations.OkapiBM25" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.StringAnalyzer" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.TfBuild.Builder" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.TfBuild.Implementations.Default" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.TfBuild.Implementations.FilteredDouble05" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.TfBuild.Implementations.FilteredLog" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.TfBuild.Implementations.OkapiBM25" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.RecipeAnalyze.TfIdfBuilder" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.SearchAPI.PredicateBuilder" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.SearchAPI.RESTBroker" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.SearchAPI.Search.OnlineTfIdf.DefaultOnlineTfIdfBuilder" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.SearchAPI.Search.OnlineTfIdf.WordTfIdf" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.SearchAPI.Search.SearchEngine" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.SearchAPI.Search.SearchResult" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.SearchAPI.Search.SearchResultItem" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.SearchAPI.Search.SitePageResult" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.SearchAPI.Suggestion.SuggestionEngine" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Spellcheck.SpellcheckDictionaryCreator" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeSearch.Spellcheck.Spellchecker" type="CLS"></ProjectItem>
  </Items>
</Project>


<Class name="RecipeSearch.Data.Base.Entity">
<Super>%Persistent</Super>
<TimeChanged>63685,85672</TimeChanged>
<TimeCreated>63610,79980.536971</TimeCreated>

<Property name="CreatedDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="ModifiedDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="IsActive">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearch.Data.Base.EntityD</DataLocation>
<DefaultData>EntityDefaultData</DefaultData>
<IdLocation>^RecipeSearch.Data.Base.EntityD</IdLocation>
<IndexLocation>^RecipeSearch.Data.Base.EntityI</IndexLocation>
<StreamLocation>^RecipeSearch.Data.Base.EntityS</StreamLocation>
<Data name="EntityDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CreatedDate</Value>
</Value>
<Value name="3">
<Value>ModifiedDate</Value>
</Value>
<Value name="4">
<Value>IsActive</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.Data.Config">
<Super>RecipeSearch.Data.Base.Entity</Super>
<TimeChanged>63983,71208.276908</TimeChanged>
<TimeCreated>63610,79444.886551</TimeCreated>

<Property name="LoggingEnabled">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="EnhancedKeywordProcessing">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="MaxPagesToCrawl">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="MaxCrawlDepth">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="MaxConcurrentThreads">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="CrawlTimeoutSeconds">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="ExtendedKeywordsMinWordCount">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="ExtendedKeywordsUseFilter">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="EnableSpellcheckDictionaryUpdate">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="BuildTf">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="TfBuilderName">
<Type>%String</Type>
<Required>1</Required>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ConfigDefaultData</DefaultData>
<Data name="ConfigDefaultData">
<Subscript>"Config"</Subscript>
<Value name="1">
<Value>LoggingEnabled</Value>
</Value>
<Value name="2">
<Value>EnhancedKeywordProcessing</Value>
</Value>
<Value name="3">
<Value>MaxPagesToCrawl</Value>
</Value>
<Value name="4">
<Value>MaxCrawlDepth</Value>
</Value>
<Value name="5">
<Value>MaxConcurrentThreads</Value>
</Value>
<Value name="6">
<Value>CrawlTimeoutSeconds</Value>
</Value>
<Value name="7">
<Value>EnableSpellcheckDictionaryUpdate</Value>
</Value>
<Value name="8">
<Value>TfBuilderName</Value>
</Value>
<Value name="9">
<Value>BuildTf</Value>
</Value>
<Value name="10">
<Value>ExtendedKeywordsMinWordCount</Value>
</Value>
<Value name="11">
<Value>ExtendedKeywordsUseFilter</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.Data.CrawlingHistoryItem">
<Super>RecipeSearch.Data.Base.Entity</Super>
<TimeChanged>63686,17.696687</TimeChanged>
<TimeCreated>63610,86227.669281</TimeCreated>

<Property name="SiteId">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="StardDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="EndDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="CrawledPagesCount">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="IsStopped">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<ForeignKey name="SiteToCrawl">
<Properties>SiteId</Properties>
<ReferencedClass>RecipeSearch.Data.SiteToCrawl</ReferencedClass>
</ForeignKey>

<Method name="ClearAllHistory">
<ClassMethod>1</ClassMethod>
<Language>tsql</Language>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[	UPDATE RecipeSearch_Data.CrawlingHistoryItem SET IsActive = 0
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>CrawlingHistoryItemDefaultData</DefaultData>
<Data name="CrawlingHistoryItemDefaultData">
<Subscript>"CrawlingHistoryItem"</Subscript>
<Value name="1">
<Value>SiteId</Value>
</Value>
<Value name="2">
<Value>StardDate</Value>
</Value>
<Value name="3">
<Value>EndDate</Value>
</Value>
<Value name="4">
<Value>CrawledPagesCount</Value>
</Value>
<Value name="5">
<Value>IsStopped</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.Data.RecipeData.NearestResult">
<Super>%Persistent</Super>
<TimeChanged>63905,56283.446969</TimeChanged>
<TimeCreated>63683,79491.18148</TimeCreated>

<Property name="RecipeId">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="SimilarRecipeId">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="Order">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="Weight">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Index name="MainIDX">
<PrimaryKey>1</PrimaryKey>
<Properties>RecipeId,SimilarRecipeId</Properties>
</Index>

<ForeignKey name="SitePage">
<Properties>RecipeId</Properties>
<ReferencedClass>RecipeSearch.Data.SitePage</ReferencedClass>
</ForeignKey>

<Query name="GetSimilarResults">
<Type>%SQLQuery</Type>
<SqlName>NearestResult_GetSimilarResults</SqlName>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT RecipeId, SimilarRecipeId, Weight FROM RecipeSearch_Data_RecipeData.NearestResult</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearch769D.NearestResultD</DataLocation>
<DefaultData>NearestResultDefaultData</DefaultData>
<IdLocation>^RecipeSearch769D.NearestResultD</IdLocation>
<IndexLocation>^RecipeSearch769D.NearestResultI</IndexLocation>
<StreamLocation>^RecipeSearch769D.NearestResultS</StreamLocation>
<Data name="NearestResultDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>RecipeId</Value>
</Value>
<Value name="3">
<Value>SimilarRecipeId</Value>
</Value>
<Value name="4">
<Value>Order</Value>
</Value>
<Value name="5">
<Value>Weight</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.Data.RecipeData.RecipeCluster">
<Super>%Persistent</Super>
<TimeChanged>63969,51748.046097</TimeChanged>
<TimeCreated>63969,47787.49702</TimeCreated>

<Property name="RecipeId">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="ClusterId">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<ForeignKey name="SitePage">
<Properties>RecipeId</Properties>
<ReferencedClass>RecipeSearch.Data.SitePage</ReferencedClass>
</ForeignKey>

<Index name="MainIDX">
<PrimaryKey>1</PrimaryKey>
<Properties>RecipeId,ClusterId</Properties>
</Index>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearch769D.RecipeClusterD</DataLocation>
<DefaultData>RecipeClusterDefaultData</DefaultData>
<IdLocation>^RecipeSearch769D.RecipeClusterD</IdLocation>
<IndexLocation>^RecipeSearch769D.RecipeClusterI</IndexLocation>
<StreamLocation>^RecipeSearch769D.RecipeClusterS</StreamLocation>
<Data name="RecipeClusterDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>RecipeId</Value>
</Value>
<Value name="3">
<Value>ClusterId</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.Data.RecipeData.WordsTF">
<Super>%Persistent</Super>
<TimeChanged>63724,69343.414141</TimeChanged>
<TimeCreated>63683,65238.598919</TimeCreated>

<Property name="RecipeId">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="Word">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="200"/>
</Property>

<Property name="TF">
<Type>%Double</Type>
<Required>1</Required>
</Property>

<Property name="WordCount">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="TFIDF">
<Type>%Double</Type>
</Property>

<ForeignKey name="SitePage">
<Properties>RecipeId</Properties>
<ReferencedClass>RecipeSearch.Data.SitePage</ReferencedClass>
</ForeignKey>

<Index name="MainIDX">
<PrimaryKey>1</PrimaryKey>
<Properties>RecipeId,Word</Properties>
</Index>

<Index name="WordIDX">
<Properties>Word</Properties>
</Index>

<Index name="TFIDFIDX">
<Properties>TFIDF,RecipeId</Properties>
</Index>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearch.Data769D.WordsTFD</DataLocation>
<DefaultData>WordsTFDefaultData</DefaultData>
<IdLocation>^RecipeSearch.Data769D.WordsTFD</IdLocation>
<IndexLocation>^RecipeSearch.Data769D.WordsTFI</IndexLocation>
<StreamLocation>^RecipeSearch.Data769D.WordsTFS</StreamLocation>
<Data name="WordsTFDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>RecipeId</Value>
</Value>
<Value name="3">
<Value>Word</Value>
</Value>
<Value name="4">
<Value>TF</Value>
</Value>
<Value name="5">
<Value>WordCount</Value>
</Value>
<Value name="6">
<Value>TFIDF</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.Data.SearchSettings">
<Super>RecipeSearch.Data.Base.Entity</Super>
<TimeChanged>64087,56637.807373</TimeChanged>
<TimeCreated>63610,79681.607063</TimeCreated>

<Property name="ResultsOnPage">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="SuggestionsCount">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="ResultsForGraphView">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="DefaultResultsView">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="EnableSpellchecking">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="EnableSpellcheckingForSuggest">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="OnlineTfIdfEnabled">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="UseClusters">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="SkipIrrelevantResults">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="SeparateClustersOnGraphView">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="OnlySearchResultsWhenUsingClusters">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="FilterSearchQuery">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="MaxOnlineIdfRecipesCount">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="OnlineTfIdfSimilarResultsCount">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="OnlineTfIdfBuilderName">
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="UseCache">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="CacheTimeout">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Query name="GetOnlineTfIdfBuilders">
<Type>%SQLQuery</Type>
<SqlProc>1</SqlProc>
<SqlQuery>	select 'DefaultOnlineTfIdfBuilder'</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>SearchSettingsDefaultData</DefaultData>
<Data name="SearchSettingsDefaultData">
<Subscript>"SearchSettings"</Subscript>
<Value name="1">
<Value>ResultsOnPage</Value>
</Value>
<Value name="2">
<Value>SuggestionsCount</Value>
</Value>
<Value name="3">
<Value>EnableSpellchecking</Value>
</Value>
<Value name="4">
<Value>EnableSpellcheckingForSuggest</Value>
</Value>
<Value name="5">
<Value>ResultsForGraphView</Value>
</Value>
<Value name="6">
<Value>DefaultResultsView</Value>
</Value>
<Value name="7">
<Value>OnlineTfIdfEnabled</Value>
</Value>
<Value name="8">
<Value>MaxOnlineIdfRecipesCount</Value>
</Value>
<Value name="9">
<Value>OnlineTfIdfBuilderName</Value>
</Value>
<Value name="10">
<Value>OnlineTfIdfSimilarResultsCount</Value>
</Value>
<Value name="11">
<Value>UserClusters</Value>
</Value>
<Value name="12">
<Value>UseClusters</Value>
</Value>
<Value name="13">
<Value>SkipIrrelevantResults</Value>
</Value>
<Value name="14">
<Value>FilterSearchQuery</Value>
</Value>
<Value name="15">
<Value>SeparateClustersOnGraphView</Value>
</Value>
<Value name="16">
<Value>OnlySearchResultsWhenUsingClusters</Value>
</Value>
<Value name="17">
<Value>UseCache</Value>
</Value>
<Value name="18">
<Value>CacheTimeout</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.Data.SitePage">
<Super>%Persistent</Super>
<TimeChanged>64151,61145.99307</TimeChanged>
<TimeCreated>63581,84906.169887</TimeCreated>

<Property name="URL">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="RecipeName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100"/>
</Property>

<Property name="Keywords">
<Type>%Text</Type>
<Parameter name="LANGUAGECLASS" value="%Text.Russian"/>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="ExtendedKeywords">
<Type>%Text</Type>
<Parameter name="LANGUAGECLASS" value="%Text.Russian"/>
<Parameter name="MAXLEN" value="10000"/>
</Property>

<Property name="Description">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="Ingredients">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="RecipeInstructions">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="AdditionalData">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="ImageUrl">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="Category">
<Type>%String</Type>
<Parameter name="MAXLEN" value="300"/>
</Property>

<Property name="Rating">
<Type>%Integer</Type>
</Property>

<Property name="CommentsCount">
<Type>%Integer</Type>
</Property>

<Property name="SiteId">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="CreatedDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="ModifiedDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="IsActive">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
<Required>1</Required>
</Property>

<ForeignKey name="SiteToCrawl">
<Properties>SiteId</Properties>
<ReferencedClass>RecipeSearch.Data.SiteToCrawl</ReferencedClass>
</ForeignKey>

<Index name="MainIDX">
<PrimaryKey>1</PrimaryKey>
<Properties>SiteId,URL</Properties>
</Index>

<Index name="KeywordsIDX">
<Properties>ExtendedKeywords(KEYS)</Properties>
</Index>

<Index name="RecipeUQIDX">
<Properties>SiteId,RecipeName</Properties>
<Unique>1</Unique>
</Index>

<Method name="Upsert">
<ClassMethod>1</ClassMethod>
<FormalSpec>URL:%String(MAXLEN=255),Keywords:%String(MAXLEN=1000),RecipeName:%String(MAXLEN=100),Description:%String(MAXLEN=100000),Ingredients:%String(MAXLEN=100000),RecipeInstructions:%String(MAXLEN=100000),AdditionalData:%String(MAXLEN=100000),ImageUrl:%String(MAXLEN=2000),Category:%String(MAXLEN=300),Rating:%Integer,CommentsCount:%Integer,SiteId:%Integer,ProcessKeywords:%Boolean,UpdateSpellcheckDict:%Boolean,BuildTf:%Boolean,TfBuilderName:%String,ExtendedKeywordsMinWordCount:%Integer,ExtendedKeywordsUseFilter:%Boolean</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	set keywordsAnalyzed = Keywords
	IF ProcessKeywords{
		set keywordsAnalyzed = ##class(RecipeSearch.Data.SitePage).BuildExtendedKeywords(
			Keywords,
			RecipeName,
			Description,
			Ingredients,
			RecipeInstructions,
			AdditionalData,
			ExtendedKeywordsMinWordCount,
			ExtendedKeywordsUseFilter)
	}
	
	if keywordsAnalyzed = "" {
		return
	}
	
	IF UpdateSpellcheckDict{
		do ##class(RecipeSearch.Spellcheck.SpellcheckDictionaryCreator).AddSitePageData(
			Keywords,
			Ingredients,
			RecipeInstructions,
			RecipeName,
			AdditionalData,
			Description)
	}
		
	&sql(select id into :recipeId from RecipeSearch_Data.SitePage WHERE url = :URL AND SiteId = :SiteId)
		
	if recipeId '= ""{
		&sql(UPDATE SitePage SET 
			AdditionalData = :AdditionalData,
			Description = :Description,
			Ingredients = :Ingredients,
			RecipeInstructions = :RecipeInstructions, 
			Keywords = :Keywords,
			ExtendedKeywords = :keywordsAnalyzed,
			RecipeName = :RecipeName, 
			ImageUrl = :ImageUrl, 
			Category = :Category,
			Rating = :Rating,
			CommentsCount = :CommentsCount,
			ModifiedDate = GETUTCDATE()			
			WHERE id = :recipeId)
	} else{		
		&sql(INSERT INTO SitePage(
			SiteId, 
			URL, 
			Description,
			Ingredients,
			RecipeInstructions,
			AdditionalData,
			ImageUrl, 
			Keywords, 
			ExtendedKeywords, 
			RecipeName, 
			Category,
			Rating,
			CommentsCount,
			CreatedDate, 
			ModifiedDate,
			IsActive) 
		VALUES(
			:SiteId, 
			:URL, 
			:Description,
			:Ingredients,
			:RecipeInstructions,
			:AdditionalData,
			:ImageUrl, 
			:Keywords, 
			:keywordsAnalyzed, 
			:RecipeName, 
			:Category,
			:Rating,
			:CommentsCount,
			GETUTCDATE(), 
			GETUTCDATE(),
			1))
	}

	if BuildTf{
		&sql(select id into :recipeId from RecipeSearch_Data.SitePage WHERE url = :URL AND SiteId = :SiteId)
		do $classmethod("RecipeSearch.RecipeAnalyze.TfBuild.Implementations."_TfBuilderName, "BuildTF",
    		recipeId, 
    		Keywords, 
    		RecipeName, 
    		Description, 
    		Ingredients, 
    		RecipeInstructions, 
    		AdditionalData)
	}
]]></Implementation>
</Method>

<Method name="BuildExtendedKeywords">
<ClassMethod>1</ClassMethod>
<FormalSpec>Keywords:%String(MAXLEN=1000),RecipeName:%String(MAXLEN=100),Description:%String(MAXLEN=100000),Ingredients:%String(MAXLEN=100000),RecipeInstructions:%String(MAXLEN=100000),AdditionalData:%String(MAXLEN=100000),ExtendedKeywordsMinWordCount:%Integer,ExtendedKeywordsUseFilter:%Boolean</FormalSpec>
<ReturnType>%String</ReturnType>
<ReturnTypeParams>MAXLEN=10000</ReturnTypeParams>
<Implementation><![CDATA[
	set extendedKeywords = 
		Keywords_";"_Description_";"_Ingredients
		_";"_RecipeInstructions_";"_AdditionalData
	
	set extendedKeywordsList = ##class(RecipeSearch.RecipeAnalyze.StringAnalyzer).GetEntitiesInText(extendedKeywords)
	set length = $LISTLENGTH(extendedKeywordsList)
	set extendedKeywords = ""
	
	for i=1:1:length{
		set word = $LIST(extendedKeywordsList, i)
		
		if word = ""{
			continue
		}
		
		if (ExtendedKeywordsUseFilter) && ($GET(^allDict(word)) '= 1) {
			continue
		}
		
		set count = 1
		for j=i+1:1:length{
			if $LIST(extendedKeywordsList, j) = word{
				set $LIST(extendedKeywordsList, j) = ""
				set count = count + 1
			}
		}
		
		if count >= ExtendedKeywordsMinWordCount {
			set extendedKeywords = extendedKeywords_" "_word
			
		}	
	}
	
	set recipeNameKeywordsList = ##class(RecipeSearch.RecipeAnalyze.StringAnalyzer).GetEntitiesInText(RecipeName)
	
	// Keywords from recipe name should never be excluded.
	for i=1:1:$LISTLENGTH(recipeNameKeywordsList){
		set word = $LIST(recipeNameKeywordsList, i)
		set extendedKeywords = extendedKeywords_" "_word
	}
	
	return extendedKeywords
]]></Implementation>
</Method>

<Method name="DeleteRecordsForSiteId">
<ClassMethod>1</ClassMethod>
<FormalSpec>SiteId:%Integer</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	&sql(DELETE %NOLOCK FROM RecipeSearch_Data_RecipeData.NearestResult 
		WHERE RecipeId IN (SELECT Id FROM RecipeSearch_data.SitePage WHERE SiteID = :SiteId))
	&sql(DELETE %NOLOCK FROM RecipeSearch_Data_RecipeData.RecipeCluster 
		WHERE RecipeId IN (SELECT Id FROM RecipeSearch_data.SitePage WHERE SiteID = :SiteId))	
	&sql(DELETE %NOLOCK FROM RecipeSearch_Data_RecipeData.WordsTF 
		WHERE RecipeId IN (SELECT Id FROM RecipeSearch_data.SitePage WHERE SiteID = :SiteId))
	&sql(DELETE %NOLOCK FROM RecipeSearch_Data.SitePage WHERE SiteID = :SiteId)
]]></Implementation>
</Method>

<Method name="DeleteSitesRecords">
<ClassMethod>1</ClassMethod>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	&sql(DELETE %NOLOCK FROM RecipeSearch_Data_RecipeData.NearestResult)
	&sql(DELETE %NOLOCK FROM RecipeSearch_Data_RecipeData.RecipeCluster)
	&sql(DELETE %NOLOCK FROM RecipeSearch_Data_RecipeData.WordsTF)
	&sql(DELETE %NOLOCK FROM RecipeSearch_Data.SitePage)
]]></Implementation>
</Method>

<Query name="GetRecordsBySiteId">
<Type>%SQLQuery</Type>
<SqlName>SitePage_GetRecordsBySiteId</SqlName>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT SiteId AS SiteId, COUNT(*) AS PageCount
	FROM SitePage
	GROUP BY SiteId</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Query name="GetTFIDF">
<Type>%SQLQuery</Type>
<SqlName>SitePage_GetTFIDF</SqlName>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT tf.Id, tf.RecipeId, sp.Category AS RecipeCategory, tf.Word, tf.TFIDF 
	FROM RecipeSearch_Data_RecipeData.WordsTF tf
	INNER JOIN RecipeSearch_Data.SitePage sp ON tf.RecipeId = sp.Id</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Method name="UpdateNearestResults">
<ClassMethod>1</ClassMethod>
<FormalSpec>PageId:%Integer,NearestResults:%String(MAXLEN=2000)</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	&sql(DELETE %NOLOCK FROM RecipeSearch_Data_RecipeData.NearestResult WHERE RecipeId = :PageId)
	
	set similarResults = $LISTFROMSTRING(NearestResults," ")
	
	for i=1:1:$LISTLENGTH(similarResults){
		set recipeData = $LISTFROMSTRING($LIST(similarResults,i),";")
		
		if $LISTLENGTH(recipeData) '= 2 {
			return
		}
		
		set recipeId = $LIST(recipeData, 1)
		set recipeWeight = $LIST(recipeData, 2)
			
		&sql(INSERT %NOLOCK INTO RecipeSearch_Data_RecipeData.NearestResult
			(RecipeId, SimilarRecipeId, Order, Weight) 
			VALUES(:PageId, CAST(:recipeId AS INT), :i, CAST(:recipeWeight AS INT)))
	}
]]></Implementation>
</Method>

<Method name="UpdateClusterId">
<ClassMethod>1</ClassMethod>
<FormalSpec>PageId:%Integer,ClusterIdsString:%String(MAXLEN=2000)</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	&sql(DELETE %NOLOCK FROM RecipeSearch_Data_RecipeData.RecipeCluster WHERE RecipeId = :PageId)
	
	set clusterIds = $LISTFROMSTRING(ClusterIdsString," ")
	
	for i=1:1:$LISTLENGTH(clusterIds){
		set clusterId = $LIST(clusterIds, i)
		
		&sql(INSERT %NOLOCK INTO RecipeSearch_Data_RecipeData.RecipeCluster
			(RecipeId, ClusterId) 
			VALUES(:PageId, CAST(:clusterId AS INT)))
	}
]]></Implementation>
</Method>

<Query name="GetTFIDFStatistic">
<Type>%SQLQuery</Type>
<SqlName>SitePage_GetTFIDFStatistic</SqlName>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT CAST(((select COUNT(Id) FROM RecipeSearch_Data.SitePage) - (select COUNT(DISTINCT RecipeId) from RecipeSearch_Data_RecipeData.WordsTf WHERE TFIDF IS NOT NULL)) AS INT) AS EmptyTfIdfCount</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Query name="GetNearestResultsStatistic">
<Type>%SQLQuery</Type>
<SqlName>SitePage_GetNearestResultsStatistic</SqlName>
<SqlProc>1</SqlProc>
<SqlQuery>	select ((select COUNT(Id) FROM RecipeSearch_Data.SitePage) - (select COUNT(DISTINCT RecipeId) FROM RecipeSearch_Data_RecipeData.NearestResult)) AS NearestResults</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Query name="GetTfStatistic">
<Type>%SQLQuery</Type>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT CAST(((select COUNT(Id) FROM RecipeSearch_Data.SitePage) - (select COUNT(DISTINCT RecipeId) from RecipeSearch_Data_RecipeData.WordsTf)) AS INT) AS EmptyTfCount</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Query name="GetClustersStatistic">
<Type>%SQLQuery</Type>
<SqlProc>1</SqlProc>
<SqlQuery>	select ((select CAST(COUNT(Id) AS INT) FROM RecipeSearch_Data.SitePage) - (select CAST(COUNT(DISTINCT RecipeId) AS INT) FROM RecipeSearch_Data_RecipeData.RecipeCluster)) AS Clusters</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Query name="GetRecipesCount">
<Type>%SQLQuery</Type>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT COUNT(Id), Min(Id), Max(Id) FROM RecipeSearch_Data.SitePage</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Method name="GetIdfStatisticProc">
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	set hasGlobalIdf = $DATA(^globalIdf) '= 0
	return hasGlobalIdf
]]></Implementation>
</Method>

<Query name="GetIdfStatistic">
<Type>%SQLQuery</Type>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT CAST(RecipeSearch_Data.SitePage_GetIdfStatisticProc() AS INT) AS IdfGlobalExists</SqlQuery>
</Query>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearch.Data.SitePageD</DataLocation>
<DefaultData>SitePageDefaultData</DefaultData>
<IdLocation>^RecipeSearch.Data.SitePageD</IdLocation>
<IndexLocation>^RecipeSearch.Data.SitePageI</IndexLocation>
<StreamLocation>^RecipeSearch.Data.SitePageS</StreamLocation>
<Data name="SitePageDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>URL</Value>
</Value>
<Value name="3">
<Value>RecipeName</Value>
</Value>
<Value name="4">
<Value>Keywords</Value>
</Value>
<Value name="5">
<Value>ExtendedKeywords</Value>
</Value>
<Value name="6">
<Value>Description</Value>
</Value>
<Value name="7">
<Value>Ingredients</Value>
</Value>
<Value name="8">
<Value>RecipeInstructions</Value>
</Value>
<Value name="9">
<Value>AdditionalData</Value>
</Value>
<Value name="10">
<Value>WordsTfIdf</Value>
</Value>
<Value name="11">
<Value>ImageUrl</Value>
</Value>
<Value name="12">
<Value>SiteId</Value>
</Value>
<Value name="13">
<Value>CreatedDate</Value>
</Value>
<Value name="14">
<Value>ModifiedDate</Value>
</Value>
<Value name="15">
<Value>IsActive</Value>
</Value>
<Value name="16">
<Value>Category</Value>
</Value>
<Value name="17">
<Value>Rating</Value>
</Value>
<Value name="18">
<Value>CommentsCount</Value>
</Value>
<Value name="19">
<Value>ClusterId</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.Data.SiteToCrawl">
<Super>RecipeSearch.Data.Base.Entity</Super>
<TimeChanged>63685,84272.753661</TimeChanged>
<TimeCreated>63610,79732.940998</TimeCreated>

<Property name="Name">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="URL">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="ConfigId">
<Type>%Integer</Type>
</Property>

<Property name="ParserId">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100"/>
</Property>

<ForeignKey name="Config">
<Properties>ConfigId</Properties>
<ReferencedClass>RecipeSearch.Data.Config</ReferencedClass>
</ForeignKey>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>SiteToCrawlDefaultData</DefaultData>
<Data name="SiteToCrawlDefaultData">
<Subscript>"SiteToCrawl"</Subscript>
<Value name="1">
<Value>Name</Value>
</Value>
<Value name="2">
<Value>URL</Value>
</Value>
<Value name="3">
<Value>ConfigId</Value>
</Value>
<Value name="4">
<Value>ParserId</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.Data.TfIdfConfig">
<Super>RecipeSearch.Data.Base.Entity</Super>
<TimeChanged>64151,54794.966893</TimeChanged>
<TimeCreated>63610,79444.886551</TimeCreated>

<Property name="TfBuilderName">
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="IdfBuilderName">
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="LastUsedTfBuilder">
<Type>%String</Type>
</Property>

<Property name="LastUsedIdfBuilder">
<Type>%String</Type>
</Property>

<Property name="SimilarResultsCount">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="SimilarResultsSameCategoryOnly">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="ClustersBuilder">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="ClusteringParameters">
<Type>%String</Type>
<Parameter name="MAXLEN" value="20000"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>TfIdfConfigDefaultData</DefaultData>
<Data name="TfIdfConfigDefaultData">
<Subscript>"TfIdfConfig"</Subscript>
<Value name="1">
<Value>TfBuilderName</Value>
</Value>
<Value name="2">
<Value>IdfBuilderName</Value>
</Value>
<Value name="5">
<Value>LastUsedTfBuilder</Value>
</Value>
<Value name="6">
<Value>LastUsedIdfBuilder</Value>
</Value>
<Value name="7">
<Value>SimilarResultsCount</Value>
</Value>
<Value name="8">
<Value>ClusterThreshold</Value>
</Value>
<Value name="9">
<Value>ClustersBuilder</Value>
</Value>
<Value name="10">
<Value>ClusteringParametersJSON</Value>
</Value>
<Value name="11">
<Value>ClusteringParameters</Value>
</Value>
<Value name="12">
<Value>SimilarResultsSameCategoryOnly</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.Data.Utils.Seed">
<Super>%RegisteredObject</Super>
<TimeChanged>64151,54845.292053</TimeChanged>
<TimeCreated>63611,44219.144767</TimeCreated>

<Method name="Run">
<ClassMethod>1</ClassMethod>
<Language>tsql</Language>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	// Seed crawler config
	IF NOT EXISTS(SELECT * FROM RecipeSearch_Data.Config) THEN BEGIN
		INSERT INTO RecipeSearch_Data.Config(
		LoggingEnabled,
		 BuildTf,
		 EnhancedKeywordProcessing,
		 EnableSpellcheckDictionaryUpdate,
		 MaxPagesToCrawl,
		 TfBuilderName,
		 MaxConcurrentThreads,
		 MaxCrawlDepth,
		 CrawlTimeoutSeconds,
		 ExtendedKeywordsMinWordCount,
		 ExtendedKeywordsUseFilter,
		 IsActive,
		 CreatedDate,
		 ModifiedDate) 
		VALUES(0, 0, 1, 1, 100000, 'DefaultTfBuilder', 10, 100000, 0, 0, 0, 1, GETUTCDATE(), GETUTCDATE());
		
		DECLARE @ConfigId AS INT;
		SELECT TOP 1 @ConfigId = Id FROM RecipeSearch_Data.Config;

		// Seed sites to crawl		
		INSERT INTO RecipeSearch_Data.SiteToCrawl(Name, URL, ConfigId, ParserId, IsActive, CreatedDate, ModifiedDate) 
		VALUES('say7', 'http://www.say7.info/', @ConfigId, 'Say7', 1, GETUTCDATE(), GETUTCDATE());
		INSERT INTO RecipeSearch_Data.SiteToCrawl(Name, URL, ConfigId,ParserId, IsActive, CreatedDate, ModifiedDate) 
		VALUES('edimdoma', 'http://www.edimdoma.ru/', @ConfigId,'EdimDoma', 1, GETUTCDATE(), GETUTCDATE());
		INSERT INTO RecipeSearch_Data.SiteToCrawl(Name, URL, ConfigId,ParserId, IsActive, CreatedDate, ModifiedDate) 
		VALUES('kedem', 'http://kedem.ru/', @ConfigId,'Kedem', 1, GETUTCDATE(), GETUTCDATE());
		INSERT INTO RecipeSearch_Data.SiteToCrawl(Name, URL, ConfigId,ParserId, IsActive, CreatedDate, ModifiedDate) 
		VALUES('gotovim-doma', 'http://gotovim-doma.ru/', @ConfigId,'GotovimDoma', 1, GETUTCDATE(), GETUTCDATE());
		INSERT INTO RecipeSearch_Data.SiteToCrawl(Name, URL, ConfigId,ParserId, IsActive, CreatedDate, ModifiedDate) 
		VALUES('koolinar', 'http://www.koolinar.ru', @ConfigId,'Kulinar', 1, GETUTCDATE(), GETUTCDATE());
	
	END
	
	// Delete crawling history
	DELETE FROM RecipeSearch_Data.CrawlingHistoryItem
	
	// Seed search settings
	IF NOT EXISTS(SELECT * FROM RecipeSearch_Data.SearchSettings) THEN BEGIN
		INSERT INTO RecipeSearch_Data.SearchSettings(
			DefaultResultsView,
			ResultsOnPage,
			ResultsForGraphView,
			SuggestionsCount,
			EnableSpellchecking,
			EnableSpellcheckingForSuggest,
			OnlineTfIdfEnabled,
			MaxOnlineIdfRecipesCount,
			OnlineTfIdfBuilderName,
			OnlineTfIdfSimilarResultsCount,
			UseClusters,
			SkipIrrelevantResults,
			FilterSearchQuery,
			SeparateClustersOnGraphView,
			OnlySearchResultsWhenUsingClusters,
			UseCache,
			CacheTimeout,
			IsActive,
			CreatedDate,
			ModifiedDate) 
		VALUES(1, 25, 50, 10, 1, 1, 0, 200, 'DefaultOnlineTfIdfBuilder', 10, 0, 0, 0, 1, 0, 1, 1, 60, GETUTCDATE(), GETUTCDATE());
	END
	
	// Seed tfIdf config
	IF NOT EXISTS(SELECT * FROM RecipeSearch_Data.TfIdfConfig) THEN BEGIN
		INSERT INTO RecipeSearch_Data.TfIdfConfig(
		TfBuilderName, 
		IdfBuilderName, 
		SimilarResultsCount, 
		SimilarResultsSameCategoryOnly,
		ClustersBuilder, 
		IsActive, 
		CreatedDate, 
		ModifiedDate) 
		VALUES('Default', 'Default', 10, 0, 1, 1, GETUTCDATE(), GETUTCDATE());
	END
]]></Implementation>
</Method>

<Method name="LoadDictionaries">
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	
	do ##class(%Text.Russian).LoadDict(directory_"\morphs.mrd")
	
	kill ^SpellcheckDict
	do ##class(RecipeSearch.Spellcheck.SpellcheckDictionaryCreator).LoadSpellcheckDictionaryFromFile(directory_"\RecipeSearch.Spellcheck.txt")
	do ##class(RecipeSearch.Spellcheck.SpellcheckDictionaryCreator).CreateSpellcheckDictionaryFromDB()
	do ##class(RecipeSearch.Data.Utils.Seed).ReadRecipesDictionaryToGlobal(directory_"\dictionary.txt")
]]></Implementation>
</Method>

<Method name="ReadRecipesDictionaryToGlobal">
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<Implementation><![CDATA[
	kill ^allDict
	
	close filename
	open filename:("RK\CP1251\"):5 if '$test { return 0 }
	
	use filename	   
    read stringnum
	
	for i=1:1:stringnum {
		read word
		set ^allDict(word) = 1
	}
	
	close filename
	quit 1
]]></Implementation>
</Method>
</Class>


<Class name="RecipeSearch.Logging.LogRecord">
<Super>%Persistent</Super>
<TimeChanged>63686,75358.36057</TimeChanged>
<TimeCreated>63611,44722.841798</TimeCreated>

<Property name="Type">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="Description">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="Exception">
<Type>%String</Type>
<Parameter name="MAXLEN" value="10000"/>
</Property>

<Property name="CreatedDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Parameter name="LogErrorType">
<Final>1</Final>
<Default>1</Default>
</Parameter>

<Parameter name="LogInfoType">
<Final>1</Final>
<Default>4</Default>
</Parameter>

<Method name="AddRecord">
<ClassMethod>1</ClassMethod>
<FormalSpec>LogType:%Integer,Description:%String(MAXLEN=2000),Exception:%String(MAXLEN=10000)</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	&sql(INSERT %NOLOCK INTO RecipeSearch_Logging.LogRecord
		(Type, Description, Exception, CreatedDate) 
		VALUES(:LogType, :Description, :Exception, GETUTCDATE()))
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearch.Logging.LogRecordD</DataLocation>
<DefaultData>LogRecordDefaultData</DefaultData>
<IdLocation>^RecipeSearch.Logging.LogRecordD</IdLocation>
<IndexLocation>^RecipeSearch.Logging.LogRecordI</IndexLocation>
<StreamLocation>^RecipeSearch.Logging.LogRecordS</StreamLocation>
<Data name="LogRecordDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>MaxPagesToCrawl</Value>
</Value>
<Value name="3">
<Value>Description</Value>
</Value>
<Value name="4">
<Value>Exception</Value>
</Value>
<Value name="5">
<Value>CreatedDate</Value>
</Value>
<Value name="6">
<Value>Type</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.IdfBuild.Builder">
<Super>%RegisteredObject</Super>
<TimeChanged>63922,75742.153261</TimeChanged>
<TimeCreated>63686,75832.310213</TimeCreated>

<Method name="BuildIdf">
<ClassMethod>1</ClassMethod>
<FormalSpec>builderName:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	do ##class(RecipeSearch.Logging.LogRecord).AddRecord(4, "IdfBuilder start", "")
	
	try {
    	do $classmethod("RecipeSearch.RecipeAnalyze.IdfBuild.Implementations."_builderName, "BuildIdf")
		&sql(update RecipeSearch_Data.TfIdfConfig SET LastUsedIdfBuilder = :builderName)
	}
	catch {
		do ##class(RecipeSearch.Logging.LogRecord).AddRecord(1, "IdfBuilder failed", $zerror)
		return
	}
		
	do ##class(RecipeSearch.Logging.LogRecord).AddRecord(4, "IdfBuilder finished", "")
]]></Implementation>
</Method>

<Query name="GetIdfBuilders">
<Type>%SQLQuery</Type>
<SqlProc>1</SqlProc>
<SqlQuery>	select 'Default' UNION select 'FilteredOrdinary' UNION select 'FilteredSmooth'
	 UNION select 'FilteredMax' UNION select 'OkapiBM25'</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.IdfBuild.Implementations.Default">
<Super>%Persistent</Super>
<TimeChanged>63922,45928</TimeChanged>
<TimeCreated>63882,83835.459566</TimeCreated>

<Method name="BuildIdf">
<ClassMethod>1</ClassMethod>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	kill ^globalIdf
	
	&sql(select COUNT(DISTINCT RecipeId) into :totalNumberOfDocuments from RecipeSearch_Data_RecipeData.WordsTF)
	
	&sql(declare wordsCursor cursor for
	      select LCASE(Word), COUNT(Word) as DocumentsCount from RecipeSearch_Data_RecipeData.WordsTF GROUP BY Word)        
    &sql(open wordsCursor)
    for {
	   &sql(fetch wordsCursor into :word,:documentsCount)
	   quit:(SQLCODE '= 0)

	   set ^globalIdf(word) = $ZLN(totalNumberOfDocuments / documentsCount)
    }
    &sql(close wordsCursor)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearch.RecipC927.DefaultD</DataLocation>
<DefaultData>DefaultDefaultData</DefaultData>
<IdLocation>^RecipeSearch.RecipC927.DefaultD</IdLocation>
<IndexLocation>^RecipeSearch.RecipC927.DefaultI</IndexLocation>
<StreamLocation>^RecipeSearch.RecipC927.DefaultS</StreamLocation>
<Data name="DefaultDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.IdfBuild.Implementations.FilteredMax">
<Super>%Persistent</Super>
<TimeChanged>63882,85755.523376</TimeChanged>
<TimeCreated>63882,85148.966847</TimeCreated>

<Method name="BuildIdf">
<ClassMethod>1</ClassMethod>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	kill ^globalIdf
	
    &sql(select MAX(COUNT(Word)) into :maxCount from RecipeSearch_Data_RecipeData.WordsTF GROUP BY Word)        
    
    &sql(declare wordsCursor cursor for
	      select LCASE(Word), COUNT(Word) as DocumentsCount from RecipeSearch_Data_RecipeData.WordsTF GROUP BY Word)        
    
    &sql(open wordsCursor)
    for {
	   &sql(fetch wordsCursor into :word,:documentsCount)
	   quit:(SQLCODE '= 0)
	   set inDict = $GET(^allDict(word))
	   
	   if inDict = "" {
		   continue
	   }
	   set ^globalIdf(word) = $ZLN(maxCount / documentsCount + 1)
    }
    &sql(close wordsCursor)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearch.RC927.FilteredMaxD</DataLocation>
<DefaultData>FilteredMaxDefaultData</DefaultData>
<IdLocation>^RecipeSearch.RC927.FilteredMaxD</IdLocation>
<IndexLocation>^RecipeSearch.RC927.FilteredMaxI</IndexLocation>
<StreamLocation>^RecipeSearch.RC927.FilteredMaxS</StreamLocation>
<Data name="FilteredMaxDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.IdfBuild.Implementations.FilteredOrdinary">
<Super>%Persistent</Super>
<TimeChanged>63922,45928</TimeChanged>
<TimeCreated>63882,84813.833216</TimeCreated>

<Method name="BuildIdf">
<ClassMethod>1</ClassMethod>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	kill ^globalIdf
	
	&sql(select COUNT(DISTINCT RecipeId) into :totalNumberOfDocuments from RecipeSearch_Data_RecipeData.WordsTF)
	
	&sql(declare wordsCursor cursor for
	      select LCASE(Word), COUNT(Word) as DocumentsCount from RecipeSearch_Data_RecipeData.WordsTF GROUP BY Word)        
    &sql(open wordsCursor)
    for {
	   &sql(fetch wordsCursor into :word,:documentsCount)
	   quit:(SQLCODE '= 0)
	   set inDict = $GET(^allDict(word))
	   
	   if inDict = "" {
		   continue
	   }
	   set ^globalIdf(word) = $ZLN(totalNumberOfDocuments / documentsCount)
    }
    &sql(close wordsCursor)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearC927.FilteredOrd1388D</DataLocation>
<DefaultData>FilteredOrdinaryDefaultData</DefaultData>
<IdLocation>^RecipeSearC927.FilteredOrd1388D</IdLocation>
<IndexLocation>^RecipeSearC927.FilteredOrd1388I</IndexLocation>
<StreamLocation>^RecipeSearC927.FilteredOrd1388S</StreamLocation>
<Data name="FilteredOrdinaryDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.IdfBuild.Implementations.FilteredSmooth">
<Super>%Persistent</Super>
<TimeChanged>63922,45928</TimeChanged>
<TimeCreated>63882,84741.749513</TimeCreated>

<Method name="BuildIdf">
<ClassMethod>1</ClassMethod>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	kill ^globalIdf
	
	&sql(select COUNT(DISTINCT RecipeId) into :totalNumberOfDocuments from RecipeSearch_Data_RecipeData.WordsTF)
	
	&sql(declare wordsCursor cursor for
	      select LCASE(Word), COUNT(Word) as DocumentsCount from RecipeSearch_Data_RecipeData.WordsTF GROUP BY Word)        
    &sql(open wordsCursor)
    for {
	   &sql(fetch wordsCursor into :word,:documentsCount)
	   quit:(SQLCODE '= 0)
	   set inDict = $GET(^allDict(word))
	   
	   if inDict = "" {
		   continue
	   }
	   set ^globalIdf(word) = $ZLN(totalNumberOfDocuments / documentsCount + 1)
    }
    &sql(close wordsCursor)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearcC927.FilteredSmoothD</DataLocation>
<DefaultData>FilteredSmoothDefaultData</DefaultData>
<IdLocation>^RecipeSearcC927.FilteredSmoothD</IdLocation>
<IndexLocation>^RecipeSearcC927.FilteredSmoothI</IndexLocation>
<StreamLocation>^RecipeSearcC927.FilteredSmoothS</StreamLocation>
<Data name="FilteredSmoothDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.IdfBuild.Implementations.OkapiBM25">
<Super>%Persistent</Super>
<TimeChanged>63922,75554.55932</TimeChanged>
<TimeCreated>63922,75551.938512</TimeCreated>

<Method name="BuildIdf">
<ClassMethod>1</ClassMethod>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	kill ^globalIdf
	
    &sql(select COUNT(ID) into :documentNumber from RecipeSearch_Data.SitePage)        
    
    &sql(declare wordsCursor cursor for
	      select LCASE(Word), COUNT(Word) as DocumentsCount from RecipeSearch_Data_RecipeData.WordsTF GROUP BY Word)        
    
    &sql(open wordsCursor)
    for {
	   &sql(fetch wordsCursor into :word,:documentsCount)
	   quit:(SQLCODE '= 0)
	   set inDict = $GET(^allDict(word))
	   
	   if inDict = "" {
		   continue
	   }
	   set ^globalIdf(word) = $ZLN((documentNumber - documentsCount + 0.5) / (documentsCount + 0.5))
    }
    &sql(close wordsCursor)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearch.RecC927.OkapiBM25D</DataLocation>
<DefaultData>OkapiBM25DefaultData</DefaultData>
<IdLocation>^RecipeSearch.RecC927.OkapiBM25D</IdLocation>
<IndexLocation>^RecipeSearch.RecC927.OkapiBM25I</IndexLocation>
<StreamLocation>^RecipeSearch.RecC927.OkapiBM25S</StreamLocation>
<Data name="OkapiBM25DefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.StringAnalyzer">
<TimeChanged>63681,75995.758964</TimeChanged>
<TimeCreated>63610,80153.007685</TimeCreated>

<Method name="GetEntitiesInText">
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String</FormalSpec>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	set words = ##class(RecipeSearch.RecipeAnalyze.StringAnalyzer).StemText(text) 
	return $LISTFROMSTRING(words, " ")
]]></Implementation>
</Method>

<Method name="StemText">
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set stemmer = ##class(%iKnow.Stemming.TextStemmer).%New("ru")
	return stemmer.StemWord(text)
]]></Implementation>
</Method>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.TfBuild.Builder">
<Super>%RegisteredObject</Super>
<TimeChanged>63922,70786.605347</TimeChanged>
<TimeCreated>63686,75654.215346</TimeCreated>

<Query name="BuildTfQuery">
<Type>%SQLQuery</Type>
<FormalSpec>builderName:%String,startId:%Integer,endId:%Integer</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT CAST(RecipeSearch_RecipeAnalyze_TfBuild.Builder_BuildTf(:builderName, :startId, :endId) AS INT) AS RowCount</SqlQuery>
</Query>

<Method name="BuildTf">
<ClassMethod>1</ClassMethod>
<FormalSpec>builderName:%String,startId:%Integer,endId:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	do ##class(RecipeSearch.Logging.LogRecord).AddRecord(4, "TfBuilder start. Stard id: "_startId_", End id:"_endId, "")
	set count = 0
	try {
		&sql(declare recipesCursor cursor for
	      	select ID, Keywords, RecipeName, Description, Ingredients, RecipeInstructions,AdditionalData
          	from RecipeSearch_Data.SitePage
          	WHERE Id >= :startId AND Id <= :endId)
          
    	&sql(open recipesCursor)
    	for {
	   		&sql(fetch recipesCursor into :curID,:Keywords,:RecipeName,:Description,:Ingredients,:RecipeInstructions, :AdditionalData)
	   		quit:(SQLCODE '= 0)

    		do $classmethod("RecipeSearch.RecipeAnalyze.TfBuild.Implementations."_builderName, "BuildTF",
    			curID, 
    			Keywords, 
    			RecipeName, 
    			Description, 
    			Ingredients, 
    			RecipeInstructions, 
    			AdditionalData)
    		
    		set count = count + 1
    	}
    	&sql(close recipesCursor)
    	
    	&sql(update RecipeSearch_Data.TfIdfConfig SET LastUsedTfBuilder = :builderName)
	}
	catch {
		do ##class(RecipeSearch.Logging.LogRecord).AddRecord(1, "TfBuilder failed", $zerror)
		return 0
	}
	
	do ##class(RecipeSearch.Logging.LogRecord).AddRecord(4, "TfBuilder finished", "")
	
	return count
]]></Implementation>
</Method>

<Query name="GetTfBuilders">
<Type>%SQLQuery</Type>
<SqlProc>1</SqlProc>
<SqlQuery>	select 'Default' UNION select 'FilteredLog' UNION select 'FilteredDouble05' UNION select 'OkapiBM25'</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.TfBuild.Implementations.Default">
<Super>%Persistent</Super>
<TimeChanged>63922,45928</TimeChanged>
<TimeCreated>63882,84008.15578</TimeCreated>

<Method name="BuildTF">
<ClassMethod>1</ClassMethod>
<FormalSpec>RecipeId:%Integer,Keywords:%String(MAXLEN=1000),RecipeName:%String(MAXLEN=100),Description:%String(MAXLEN=100000),Ingredients:%String(MAXLEN=100000),RecipeInstructions:%String(MAXLEN=100000),AdditionalData:%String(MAXLEN=100000)</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	set extendedKeywords = 
		Keywords_";"_RecipeName_"; "_Description_"; "_Ingredients
		_"; "_RecipeInstructions_"; "_AdditionalData
		
	set extendedKeywordsList = ##class(RecipeSearch.RecipeAnalyze.StringAnalyzer).GetEntitiesInText(extendedKeywords)
	set extendedKeywordsCountList = $LISTFROMSTRING("")
	
	set maxCount = -1
	set length = $LISTLENGTH(extendedKeywordsList)
	
	for i=1:1:length{
		set word = $LIST(extendedKeywordsList, i)
		
		if word = ""{
			set extendedKeywordsCountList = extendedKeywordsCountList_$LISTBUILD("")
			continue
		}
		
		set count = 1
		for j=i+1:1:length{
			if $LIST(extendedKeywordsList,j) = word{
				set $LIST(extendedKeywordsList,j) = ""
				set count = count + 1
			}
		}
		
		if count > maxCount{
			set maxCount = count
		}
		
		set extendedKeywordsCountList = extendedKeywordsCountList_$LISTBUILD(count)		
	}
	
	&sql(DELETE FROM RecipeSearch_Data_RecipeData.WordsTF WHERE RecipeId = :RecipeId)
	
	for i=1:1:length{
		set word = $LIST(extendedKeywordsList, i)
		set wordCount = $LIST(extendedKeywordsCountList, i)
		
		if word = ""{
			continue
		}
		
		set wordTf = 0.5 + 0.5 * wordCount / maxCount
		
		&sql(INSERT INTO RecipeSearch_Data_RecipeData.WordsTF
			(RecipeId, Word, TF, WordCount)
			VALUES(:RecipeId, :word, :wordTf, :wordCount))
	}
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearch.Recip5F19.DefaultD</DataLocation>
<DefaultData>DefaultDefaultData</DefaultData>
<IdLocation>^RecipeSearch.Recip5F19.DefaultD</IdLocation>
<IndexLocation>^RecipeSearch.Recip5F19.DefaultI</IndexLocation>
<StreamLocation>^RecipeSearch.Recip5F19.DefaultS</StreamLocation>
<Data name="DefaultDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.TfBuild.Implementations.FilteredDouble05">
<Super>%Persistent</Super>
<TimeChanged>63922,45928</TimeChanged>
<TimeCreated>63882,86033.706035</TimeCreated>

<Method name="BuildTF">
<ClassMethod>1</ClassMethod>
<FormalSpec>RecipeId:%Integer,Keywords:%String(MAXLEN=1000),RecipeName:%String(MAXLEN=100),Description:%String(MAXLEN=100000),Ingredients:%String(MAXLEN=100000),RecipeInstructions:%String(MAXLEN=100000),AdditionalData:%String(MAXLEN=100000)</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	set extendedKeywords = 
		Keywords_";"_RecipeName_"; "_Description_"; "_Ingredients
		_"; "_RecipeInstructions_"; "_AdditionalData
		
	set extendedKeywordsList = ##class(RecipeSearch.RecipeAnalyze.StringAnalyzer).GetEntitiesInText(extendedKeywords)
	set extendedKeywordsCountList = $LISTFROMSTRING("")
	
	set maxCount = -1
	set length = $LISTLENGTH(extendedKeywordsList)
	
	for i=1:1:length{
		set word = $LIST(extendedKeywordsList, i)
		
		if word = ""{
			set extendedKeywordsCountList = extendedKeywordsCountList_$LISTBUILD("")
			continue
		}
		
		set count = 1
		for j=i+1:1:length{
			if $LIST(extendedKeywordsList,j) = word{
				set $LIST(extendedKeywordsList,j) = ""
				set count = count + 1
			}
		}
		
		if count > maxCount{
			set maxCount = count
		}
		
		set extendedKeywordsCountList = extendedKeywordsCountList_$LISTBUILD(count)		
	}
	
	&sql(DELETE FROM RecipeSearch_Data_RecipeData.WordsTF WHERE RecipeId = :RecipeId)
	
	for i=1:1:length{
		set word = $LIST(extendedKeywordsList, i)
		set wordCount = $LIST(extendedKeywordsCountList, i)
		
		if word = "" {
			continue
		}
		set inDict = $GET(^allDict(word))
		
		if inDict = "" {
			continue
		}
		
		set wordTf = 0.5 + 0.5 * wordCount / maxCount
		
		&sql(INSERT INTO RecipeSearch_Data_RecipeData.WordsTF
			(RecipeId, Word, TF, WordCount)
			VALUES(:RecipeId, :word, :wordTf, :wordCount))
	}
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSear5F19.FilteredDoubDD3D</DataLocation>
<DefaultData>FilteredDouble05DefaultData</DefaultData>
<IdLocation>^RecipeSear5F19.FilteredDoubDD3D</IdLocation>
<IndexLocation>^RecipeSear5F19.FilteredDoubDD3I</IndexLocation>
<StreamLocation>^RecipeSear5F19.FilteredDoubDD3S</StreamLocation>
<Data name="FilteredDouble05DefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.TfBuild.Implementations.FilteredLog">
<Super>%Persistent</Super>
<TimeChanged>63922,45928</TimeChanged>
<TimeCreated>63882,84074.275583</TimeCreated>

<Method name="BuildTF">
<ClassMethod>1</ClassMethod>
<FormalSpec>RecipeId:%Integer,Keywords:%String(MAXLEN=1000),RecipeName:%String(MAXLEN=100),Description:%String(MAXLEN=100000),Ingredients:%String(MAXLEN=100000),RecipeInstructions:%String(MAXLEN=100000),AdditionalData:%String(MAXLEN=100000)</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	set extendedKeywords = 
		Keywords_";"_RecipeName_"; "_Description_"; "_Ingredients
		_"; "_RecipeInstructions_"; "_AdditionalData
		
	set extendedKeywordsList = ##class(RecipeSearch.RecipeAnalyze.StringAnalyzer).GetEntitiesInText(extendedKeywords)
	set extendedKeywordsCountList = $LISTFROMSTRING("")
	
	set maxCount = -1
	set length = $LISTLENGTH(extendedKeywordsList)
	
	for i=1:1:length{
		set word = $LIST(extendedKeywordsList, i)
		
		if word = ""{
			set extendedKeywordsCountList = extendedKeywordsCountList_$LISTBUILD("")
			continue
		}
		
		set count = 1
		for j=i+1:1:length{
			if $LIST(extendedKeywordsList,j) = word{
				set $LIST(extendedKeywordsList,j) = ""
				set count = count + 1
			}
		}
		
		if count > maxCount{
			set maxCount = count
		}
		
		set extendedKeywordsCountList = extendedKeywordsCountList_$LISTBUILD(count)		
	}
	
	&sql(DELETE FROM RecipeSearch_Data_RecipeData.WordsTF WHERE RecipeId = :RecipeId)
	
	for i=1:1:length{
		set word = $LIST(extendedKeywordsList, i)
		set wordCount = $LIST(extendedKeywordsCountList, i)
		
		if word = "" {
			continue
		}
		set inDict = $GET(^allDict(word))
		
		if inDict = "" {
			continue
		}

		set wordTf = $ZLN(wordCount + 1)
		
		&sql(INSERT INTO RecipeSearch_Data_RecipeData.WordsTF
			(RecipeId, Word, TF, WordCount)
			VALUES(:RecipeId, :word, :wordTf, :wordCount))
	}
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearch.R5F19.FilteredLogD</DataLocation>
<DefaultData>FilteredLogDefaultData</DefaultData>
<IdLocation>^RecipeSearch.R5F19.FilteredLogD</IdLocation>
<IndexLocation>^RecipeSearch.R5F19.FilteredLogI</IndexLocation>
<StreamLocation>^RecipeSearch.R5F19.FilteredLogS</StreamLocation>
<Data name="FilteredLogDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.TfBuild.Implementations.OkapiBM25">
<Super>%Persistent</Super>
<TimeChanged>63922,73722.267832</TimeChanged>
<TimeCreated>63922,47836.372657</TimeCreated>

<Method name="GetAvgDL">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
		set documentsCount = 0
		set wordsCount = 0

		&sql(declare documentCursor cursor for
	      	select Keywords, RecipeName, Description, Ingredients, RecipeInstructions, AdditionalData
          	from RecipeSearch_Data.SitePage)
        &sql(open documentCursor)
		for {
			&sql(fetch documentCursor into :Keywords,:RecipeName,:Description,:Ingredients,
			:RecipeInstructions,:AdditionalData)
			
			quit:(SQLCODE '= 0)
			
			set documentsCount = documentsCount + 1
			
			set extendedKeywords = Keywords_"; "_RecipeName_"; "_Description_"; "
			_Ingredients_"; "_RecipeInstructions_"; "_AdditionalData
			
			set extendedKeywordsList = ##class(RecipeSearch.RecipeAnalyze.StringAnalyzer).GetEntitiesInText(extendedKeywords)
			set length = $LISTLENGTH(extendedKeywordsList)
			
			for i=1:1:length{
				set word = $LIST(extendedKeywordsList, i)
				
				if word = "" {
					continue
				}
				
				set inDict = $GET(^allDict(word))
				
				if inDict = "" {
					continue
				}
		
				set wordsCount = wordsCount + 1
			}
		}
		&sql(close documentCursor)
		set ^avgdl(0) = wordsCount / documentsCount
]]></Implementation>
</Method>

<Method name="BuildTF">
<ClassMethod>1</ClassMethod>
<FormalSpec>RecipeId:%Integer,Keywords:%String(MAXLEN=1000),RecipeName:%String(MAXLEN=100),Description:%String(MAXLEN=100000),Ingredients:%String(MAXLEN=100000),RecipeInstructions:%String(MAXLEN=100000),AdditionalData:%String(MAXLEN=100000)</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	set averageDL = ^avgdl(0)
	
	set k1 = 2
	set b = 0.75
	
	set extendedKeywords = 
		Keywords_"; "_RecipeName_"; "_Description_"; "_Ingredients
		_"; "_RecipeInstructions_"; "_AdditionalData
		
	set extendedKeywordsList = ##class(RecipeSearch.RecipeAnalyze.StringAnalyzer).GetEntitiesInText(extendedKeywords)
	set extendedKeywordsCountList = $LISTFROMSTRING("")
	
	set length = $LISTLENGTH(extendedKeywordsList)
	
	for i=1:1:length{
		set word = $LIST(extendedKeywordsList, i)
		
		if word = ""{
			set extendedKeywordsCountList = extendedKeywordsCountList_$LISTBUILD("")
			continue
		}
		
		set count = 1
		for j=i+1:1:length{
			if $LIST(extendedKeywordsList,j) = word{
				set $LIST(extendedKeywordsList,j) = ""
				set count = count + 1
			}
		}
		
		set extendedKeywordsCountList = extendedKeywordsCountList_$LISTBUILD(count)		
	}
	
	&sql(DELETE FROM RecipeSearch_Data_RecipeData.WordsTF WHERE RecipeId = :RecipeId)
	
	set wordsInDocument = 0
	
	for i=1:1:length{
		set word = $LIST(extendedKeywordsList, i)
		set wordCount = $LIST(extendedKeywordsCountList, i)
		
		if word = "" {
			continue
		}
		set inDict = $GET(^allDict(word))
		
		if inDict = "" {
			continue
		}
		set wordsInDocument = wordsInDocument + wordCount
	}
	
	for i=1:1:length{
		set word = $LIST(extendedKeywordsList, i)
		set wordCount = $LIST(extendedKeywordsCountList, i)
		
		if word = "" {
			continue
		}
		set inDict = $GET(^allDict(word))
		
		if inDict = "" {
			continue
		}

		set wordTf = wordCount * (k1 + 1) / 
		(wordCount + k1 * (1 - b + b * wordsInDocument / averageDL))
		
		&sql(INSERT INTO RecipeSearch_Data_RecipeData.WordsTF
			(RecipeId, Word, TF, WordCount)
			VALUES(:RecipeId, :word, :wordTf, :wordCount))
	}
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^RecipeSearch.Rec5F19.OkapiBM25D</DataLocation>
<DefaultData>OkapiBM25DefaultData</DefaultData>
<IdLocation>^RecipeSearch.Rec5F19.OkapiBM25D</IdLocation>
<IndexLocation>^RecipeSearch.Rec5F19.OkapiBM25I</IndexLocation>
<StreamLocation>^RecipeSearch.Rec5F19.OkapiBM25S</StreamLocation>
<Data name="OkapiBM25DefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="RecipeSearch.RecipeAnalyze.TfIdfBuilder">
<Super>%RegisteredObject</Super>
<TimeChanged>63808,54137.944395</TimeChanged>
<TimeCreated>63686,77142.637964</TimeCreated>

<Query name="BuildTfIdfQuery">
<Type>%SQLQuery</Type>
<FormalSpec>startId:%Integer,endId:%Integer</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT CAST(RecipeSearch_RecipeAnalyze.TfIdfBuilder_CalculateTfIdf(:startId, :endId) AS INT) AS RowCount</SqlQuery>
</Query>

<Method name="CalculateTfIdf">
<ClassMethod>1</ClassMethod>
<FormalSpec>startId:%Integer,endId:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
  try {
	  
	do ##class(RecipeSearch.Logging.LogRecord).AddRecord(4, "TfIdfBuilder started. Stard id: "_startId_", End id:"_endId, "")
	set count = 0
    &sql(declare recipesCursor cursor for
	      select id from RecipeSearch_Data.SitePage
	      WHERE Id >= :startId AND Id <= :endId)        
    &sql(open recipesCursor)
    for {
	   	&sql(fetch recipesCursor into :recipeId)
	   	quit:(SQLCODE '= 0)

	   	&sql(declare recipeWordsCursor cursor for select Id, LCASE(Word), TF from RecipeSearch_Data_RecipeData.WordsTF WHERE RecipeId = :recipeId) 
	   	&sql(open recipeWordsCursor)
    	for {
	   		&sql(fetch recipeWordsCursor into :tfid, :word, :tf)
	   		
	   		quit:(SQLCODE '= 0)
	   		
	   		if $GET(^globalIdf(word), -1) = -1{
				continue
			}
	   		
	   		set tfidf = tf * ^globalIdf(word)
	   		&sql(update RecipeSearch_Data_RecipeData.WordsTF SET TFIDF = :tfidf WHERE Id = :tfid)
    	}
    	&sql(close recipeWordsCursor)
    	set count = count + 1
    }
    &sql(close recipesCursor)
    
    do ##class(RecipeSearch.Logging.LogRecord).AddRecord(4, "TfIdfBuilder finished", "")
  }
  catch{
	  do ##class(RecipeSearch.Logging.LogRecord).AddRecord(1, "TfBuilder failed", $zerror)
	  return 0
  }
  
  return count
]]></Implementation>
</Method>
</Class>


<Class name="RecipeSearch.SearchAPI.PredicateBuilder">
<Super>%RegisteredObject</Super>
<TimeChanged>64167,75408.817092</TimeChanged>
<TimeCreated>63640,44416.350546</TimeCreated>

<Method name="BuildPredicate">
<ClassMethod>1</ClassMethod>
<FormalSpec>query:%String</FormalSpec>
<Implementation><![CDATA[
	
	set queryParts = ##class(RecipeSearch.RecipeAnalyze.StringAnalyzer).GetEntitiesInText(query)
	
	set predicate = "RecipeName = '"_query_"'"
	set i = 1
	set listLength = $LISTLENGTH(queryParts)
	
	IF listLength = 0 {
		return predicate
	}
	
	set predicate = predicate_" OR ExtendedKeywords %CONTAINS("
	
	for i=1:1:listLength{
		if i '= 1{
			set predicate = predicate_", "
		}
		
		set predicate = predicate_"'"_$LIST(queryParts, i)_"'"
	}
	
	set predicate = predicate_")"
	
	return predicate
]]></Implementation>
</Method>

<Method name="BuildRelevancySubQuery">
<ClassMethod>1</ClassMethod>
<FormalSpec>query:%String</FormalSpec>
<Implementation><![CDATA[
	
	set queryParts = ##class(RecipeSearch.RecipeAnalyze.StringAnalyzer).GetEntitiesInText(query)
	
	set subquery = "0"
	set i = 1
	set listLength = $LISTLENGTH(queryParts)
	
	IF listLength = 0 {
		return subquery
	}
	
	set subquery = "(0"
	
	for i=1:1:listLength{
		set word = $LIST(queryParts, i)
		
		if $GET(^globalIdf(word), -1) = -1{
			continue
		}
		
		set subquery = subquery_" + "
										
		set subquery = subquery_"(SELECT SUM(TF)* "_^globalIdf(word)_" from RecipeSearch_Data_RecipeData.WordsTF WHERE RecipeId = sp.Id AND word = '"_word_"')"
	}
	
	set subquery = subquery_")"
	
	return subquery
]]></Implementation>
</Method>
</Class>


<Class name="RecipeSearch.SearchAPI.RESTBroker">
<Super>%CSP.REST</Super>
<TimeChanged>63985,56635.478665</TimeChanged>
<TimeCreated>63584,64787.957361</TimeCreated>

<XData name="UrlMap">
<Data><![CDATA[
<Routes>
 <Route Url="/doSearch" Method="GET" Call="Search"/>
 <Route Url="/suggest" Method="GET" Call="Suggest"/>
 </Routes>
]]></Data>
</XData>

<Method name="Search">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set query = %request.Get("query", "")
	set pageNumber = %request.Get("pageNumber", "1")
	set pageSize = %request.Get("pageSize", "25")
	
	set spellcheck = %request.Get("spellcheck", 0)
	set exactMatch = %request.Get("exactMatch", 0) // ignore spellchecking result
	
	set onlineTfIdf = %request.Get("onlineTfIdf", 0)
	set useClusters = %request.Get("useClusters", 0)
	set onlySearchResultsWhenUsingClusters = %request.Get("onlySearchResultsWhenUsingClusters", 0)
	set skipIrrelevantResults = %request.Get("skipIrrelevantResults", 0)
	set filterSearchQuery = %request.Get("filterSearchQuery", 0)
	set maxIdfRecipesCount = %request.Get("maxIdfRecipesCount", 200)
	
	set onlineTfIdfBuilderName = %request.Get("onlineTfIdfBuilderName", "DefaultOnlineTfIdfBuilder")
	
	try {
    	do ##class(RecipeSearch.SearchAPI.Search.SearchEngine).SearchPages(
    	query,
    	spellcheck,
    	exactMatch,
    	pageNumber,
    	pageSize,
    	onlineTfIdf,
    	useClusters,
    	onlySearchResultsWhenUsingClusters,
    	skipIrrelevantResults,
    	maxIdfRecipesCount,
    	onlineTfIdfBuilderName)
	} catch err {
    	write err.AsSystemError()
    }
		
	quit $$$OK
]]></Implementation>
</Method>

<Method name="Suggest">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set query = %request.Get("query", "")
	set count = %request.Get("count", "10")
	set spellcheck = %request.Get("spellcheck", 0)
	
	try {
    	do ##class(RecipeSearch.SearchAPI.Suggestion.SuggestionEngine).SuggestRecipes(query, count, spellcheck)
	} catch err {
    	write err.AsSystemError()
    }
		
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="RecipeSearch.SearchAPI.Search.OnlineTfIdf.DefaultOnlineTfIdfBuilder">
<Super>%RegisteredObject</Super>
<TimeChanged>63808,54392.885931</TimeChanged>
<TimeCreated>63808,50461.308907</TimeCreated>

<Method name="BuildTfIdf">
<ClassMethod>1</ClassMethod>
<FormalSpec>recipesIdsToCalculateIdf:%List,recipesToCalculatedTfIdf:%ListOfObjects</FormalSpec>
<Implementation><![CDATA[
	set totalNumberOfDocuments = $LISTLENGTH(recipesIdsToCalculateIdf)
	
	for i = 1:1:totalNumberOfDocuments{
		set recipeId = $LIST(recipesIdsToCalculateIdf, i)
	
		&sql(declare wordsCursor cursor for
	      select LCASE(Word), COUNT(Word) as DocumentsCount 
	      from RecipeSearch_Data_RecipeData.WordsTF 
	      WHERE RecipeId = :recipeId
	      GROUP BY Word)  
	            
    	&sql(open wordsCursor)
    	for {
	   		&sql(fetch wordsCursor into :word,:currentDocumentsCount)
	   		quit:(SQLCODE '= 0)
	   		set documentsCount(word) = $GET(documentsCount(word), 0) + currentDocumentsCount
    	}
    	
    	&sql(close wordsCursor)
	}
	
	set key = $Order(documentsCount(""))
 	while (key '= "") {
 		set localIdf(key) = $ZLN(totalNumberOfDocuments / documentsCount(key))
 		set key = $Order(documentsCount(key))
 	}

	for i=1:1:recipesToCalculatedTfIdf.Count() {		
		set recipeItem = recipesToCalculatedTfIdf.GetAt(i)
		set recipeId = recipeItem.Result.ID
	    
	    &sql(declare recipeWordsCursor cursor for select Id, LCASE(Word), TF from RecipeSearch_Data_RecipeData.WordsTF WHERE RecipeId = :recipeId) 
	   	&sql(open recipeWordsCursor)
    	for {
	   		&sql(fetch recipeWordsCursor into :tfid, :word, :tf)	   		
	   		quit:(SQLCODE '= 0)
	   		
	   		if $GET(localIdf(word), -1) = -1{
				continue
			}
	   		
	   		set tfidf = tf * localIdf(word)
	   		
	   		set wordTfIDf = ##class(RecipeSearch.SearchAPI.Search.OnlineTfIdf.WordTfIdf).%New()
	   		set wordTfIDf.Word = word
	   		set wordTfIDf.TFIDF = tfidf
	   		do recipeItem.WordsTFIDF.Insert(wordTfIDf)
    	}
    	&sql(close recipeWordsCursor)
	}
	//zw localIdf
	//
    
    //zw localIdf
]]></Implementation>
</Method>
</Class>


<Class name="RecipeSearch.SearchAPI.Search.OnlineTfIdf.WordTfIdf">
<Super>%RegisteredObject</Super>
<TimeChanged>63808,53940.42362</TimeChanged>
<TimeCreated>63808,53934.153372</TimeCreated>

<Property name="Word">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="200"/>
</Property>

<Property name="TFIDF">
<Type>%Double</Type>
</Property>
</Class>


<Class name="RecipeSearch.SearchAPI.Search.SearchEngine">
<Super>%RegisteredObject</Super>
<TimeChanged>64167,75412.734556</TimeChanged>
<TimeCreated>63598,70157.596857</TimeCreated>

<Method name="SearchPages">
<ClassMethod>1</ClassMethod>
<FormalSpec>query:%String,spellcheck:%Boolean,exactMatch:%Boolean,pageNumber:%Integer,pageSize:%Integer,onlineTfIdf:%Boolean,useClusters:%Boolean,onlySearchResultsWhenUsingClusters:%Boolean,skipIrrelevantResults:%Boolean,maxIdfRecipesCount:%Integer,onlineTfIdfBuilderName:%String</FormalSpec>
<Implementation><![CDATA[
	if spellcheck {
		set spellcheckedQuery = ##class(RecipeSearch.Spellcheck.Spellchecker).SpellcheckText(query)
		
		if 'exactMatch{
			set query = spellcheckedQuery
		}
	}
	
	set relevancyQuery = ##class(RecipeSearch.SearchAPI.PredicateBuilder).BuildRelevancySubQuery(query)
	
	set sqlQuery = "SELECT %NOLOCK" 
			_" ID,"
			_" Description,"
			_" Ingredients,"
			_" RecipeInstructions,"
			_" AdditionalData,"
			_" ImageUrl,"
			_" Keywords,"
			_" SiteId,"
			_" URL,"
			_" RecipeName, "
			_" Category, "
			_" Rating, "
			_" CommentsCOunt, "
			_relevancyQuery_" AS Relevancy,"
			_" CreatedDate," 
			_" ModifiedDate,"
			_" (SELECT CAST(LIST(ClusterId) AS NVARCHAR(200)) from RecipeSearch_Data_RecipeData.RecipeCluster WHERE RecipeId = sp.Id) AS ClusterIds"
		_" FROM RecipeSearch_Data.SitePage sp"
	
	set predicate = "("_##class(RecipeSearch.SearchAPI.PredicateBuilder).BuildPredicate(query)_")"
	
	if skipIrrelevantResults{
		set predicate = predicate_" AND "_relevancyQuery_" <> 0"
	}
	
	set sqlQuery = sqlQuery_" WHERE "_predicate_" ORDER BY Relevancy DESC, URL, SiteId"	
	
	set result = ##class(%Library.ResultSet).%New() 
	set tSC = result.Prepare(sqlQuery) 
    set tSC = result.Execute()
     
    set searchResult = ##class(RecipeSearch.SearchAPI.Search.SearchResult).PopulateFromResultSet(
    	result,
    	pageNumber,
    	pageSize,
    	onlineTfIdf,
    	useClusters,
    	onlySearchResultsWhenUsingClusters,
    	maxIdfRecipesCount,
    	onlineTfIdfBuilderName)           
	
	if spellcheck{
		set searchResult.SpellcheckedQuery = spellcheckedQuery
	}
			
	do ##class(%ZEN.Auxiliary.jsonProvider).%ObjectToJSON(searchResult)
]]></Implementation>
</Method>
</Class>


<Class name="RecipeSearch.SearchAPI.Search.SearchResult">
<Super>%RegisteredObject</Super>
<TimeChanged>64087,54228.684221</TimeChanged>
<TimeCreated>63627,74813.171587</TimeCreated>

<Property name="Items">
<Type>RecipeSearch.SearchAPI.Search.SitePageResult</Type>
<Collection>list</Collection>
</Property>

<Property name="TotalCount">
<Type>%Integer</Type>
</Property>

<Property name="PageNumber">
<Type>%Integer</Type>
</Property>

<Property name="SpellcheckedQuery">
<Type>%String</Type>
</Property>

<Method name="PopulateFromResultSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>result:%Library.ResultSet,pageNumber:%Integer,pageSize:%Integer,onlineTfIdf:%Boolean,useClusters:%Boolean,onlySearchResultsWhenUsingClusters:%Boolean,maxIdfRecipesCount:%Integer,onlineTfIdfBuilderName:%String</FormalSpec>
<ReturnType>%Library.ResultSet</ReturnType>
<Implementation><![CDATA[
	// TODO: make it more performant
	set startIndex = (pageNumber - 1) * pageSize + 1
	
	set searchResults = ##class(RecipeSearch.SearchAPI.Search.SearchResult).%New()
	set searchResults.Items = ##class(%ListOfObjects).%New()
	set recipesIdsToCalculateIdf = $LISTFROMSTRING("")
	
	set count = 0
    while (result.Next()) 
    { 
    	if count < maxIdfRecipesCount {
	    	set recipesIdsToCalculateIdf = recipesIdsToCalculateIdf_$LISTBUILD(result.Data("ID"))
    	}
    	
    	set count = count + 1 
    	
    	if (count < startIndex) && ('onlineTfIdf || (count > maxIdfRecipesCount)){
	    	
	    	continue
    	}
        
        if (count >= (startIndex + pageSize)) && ('onlineTfIdf || (count > maxIdfRecipesCount))
        {         
			continue
        } 
        
        set sitePageResult = ##class(RecipeSearch.SearchAPI.Search.SitePageResult).%New()
        
        set sitePageResult.Result = ##class(RecipeSearch.SearchAPI.Search.SearchResult).MapResultToSitePage(result, 0)      
        set sitePageResult.SimilarResults = ##class(%ListOfObjects).%New()
              
        set tSC = searchResults.Items.Insert(sitePageResult)         
	}
	
	if useClusters {
		for i=1:1:searchResults.Items.Count() {		
			set searchResultItem = searchResults.Items.GetAt(i)
			set id = searchResultItem.Result.ID
			
			if 'onlySearchResultsWhenUsingClusters {
				set searchResultItem.SimilarResults = ##class(RecipeSearch.SearchAPI.Search.SearchResult).GetClusters(id)
			} else{
				set searchResultItem.SimilarResults = ##class(%ListOfObjects).%New()
			}	        
		}
	}	
	elseif onlineTfIdf {
		
		do $classmethod("RecipeSearch.SearchAPI.Search.OnlineTfIdf."_onlineTfIdfBuilderName, "BuildTfIdf",
    		recipesIdsToCalculateIdf, 
    		searchResults.Items)
		
    } else {
	    do ##class(RecipeSearch.SearchAPI.Search.SearchResult).GetSimilarResults(searchResults.Items)
	   	//for i=1:1:searchResults.Items.Count() {		
		//	set searchResultItem = searchResults.Items.GetAt(i)
		//	set id = searchResultItem.Result.ID	        
		//}
    }

	set searchResults.PageNumber = pageNumber
	set searchResults.TotalCount = count
	
	return searchResults
]]></Implementation>
</Method>

<Method name="GetSimilarResults">
<ClassMethod>1</ClassMethod>
<FormalSpec>Recipes:%ListOfObjects</FormalSpec>
<Implementation><![CDATA[
	set recipeIdsPredicate = ""
	for i=1:1:Recipes.Count() {	
		set recipeIdsPredicate = recipeIdsPredicate_"RecipeId = "_Recipes.GetAt(i).Result.ID
		
		if i '= Recipes.Count(){
			set recipeIdsPredicate = recipeIdsPredicate_" OR "
		}
	}

	set sqlQuery = "SELECT %NOLOCK" 
			_" sp.ID,"
			_" RecipeId,"
			_" Description,"
			_" Ingredients,"
			_" RecipeInstructions,"
			_" AdditionalData,"
			_" ImageUrl,"
			_" Keywords,"
			_" SiteId,"
			_" URL,"
			_" RecipeName, "
			_" Category, "
			_" Rating, "
			_" CommentsCount, "
			_" CreatedDate," 
			_" ModifiedDate,"
			_" '-1' AS ClusterIds,"
			_" Weight AS SimilarRecipeWeight"
		_" FROM  RecipeSearch_Data_RecipeData.NearestResult"
		_" INNER JOIN RecipeSearch_Data.SitePage sp ON sp.Id = SimilarRecipeId"
		_" WHERE "_recipeIdsPredicate
		_" ORDER BY RecipeId, Order"
    
    set result = ##class(%Library.ResultSet).%New() 
	set tSC = result.Prepare(sqlQuery) 
    set tSC = result.Execute()
    
	set currentRecipe = ""
    while (result.Next()) 
    {
	    set recipeId = result.Data("RecipeId")
	    
	    set similarResult = ##class(RecipeSearch.SearchAPI.Search.SearchResult).MapResultToSitePage(result, 1)
	    
	    if currentRecipe = "" || currentRecipe.Result.ID '= recipeId {	    
		    for i=1:1:Recipes.Count() {	
		    	set recipe = Recipes.GetAt(i)
		    	if recipe.Result.ID = recipeId {
			    	set currentRecipe = recipe
			    	break
		    	}
		    }
	    }  
	    
	    do currentRecipe.SimilarResults.Insert(similarResult)
    }
]]></Implementation>
</Method>

<Method name="GetClusters">
<ClassMethod>1</ClassMethod>
<FormalSpec>RecipeId:%Integer</FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<Implementation><![CDATA[
	set similarResultsObjects = ##class(%ListOfObjects).%New()
	set sqlQuery = 
		"SELECT %NOLOCK" 
			_" sp.ID,"
			_" Description,"
			_" Ingredients,"
			_" RecipeInstructions,"
			_" AdditionalData,"
			_" ImageUrl,"
			_" Keywords,"
			_" SiteId,"
			_" URL,"
			_" RecipeName, "
			_" Category, "
			_" Rating, "
			_" CommentsCount, "
			_" CreatedDate," 
			_" ModifiedDate,"
			_" (SELECT CAST(LIST(ClusterId) AS NVARCHAR(200)) from RecipeSearch_Data_RecipeData.RecipeCluster WHERE RecipeId = sp.Id) AS ClusterIds,"
			_" 10 AS SimilarRecipeWeight"
		_" FROM  RecipeSearch_Data.SitePage sp"
		_" WHERE EXISTS(SELECT 1 FROM RecipeSearch_Data_RecipeData.RecipeCluster rc1"
		_" INNER JOIN RecipeSearch_Data_RecipeData.RecipeCluster rc2"
		_"		ON rc2.RecipeId = "_RecipeId_" AND rc2.ClusterId = rc1.ClusterId AND rc1.RecipeId = sp.Id AND rc1.RecipeId <> rc2.RecipeId)"
		_" ORDER BY sp.ID"

    set result = ##class(%Library.ResultSet).%New() 
	set tSC = result.Prepare(sqlQuery) 
    set tSC = result.Execute()
    
    while (result.Next()) 
    {
	    set similarResult = ##class(RecipeSearch.SearchAPI.Search.SearchResult).MapResultToSitePage(result, 1)
	    do similarResultsObjects.Insert(similarResult)	    	    
    }   
			    
    return similarResultsObjects
]]></Implementation>
</Method>

<Method name="CalculateSimilarResults">
<ClassMethod>1</ClassMethod>
<ReturnType>%ListOfObjects</ReturnType>
<Implementation><![CDATA[
	set similarResultsObjects = ##class(%ListOfObjects).%New()
	return similarResultsObjects
]]></Implementation>
</Method>

<Method name="MapResultToSitePage">
<ClassMethod>1</ClassMethod>
<FormalSpec>result:%Library.ResultSet,includeNearest:%Boolean</FormalSpec>
<ReturnType>RecipeSearch.SearchAPI.Search.SearchResultItem</ReturnType>
<Implementation><![CDATA[
	set sitePage = ##class(RecipeSearch.SearchAPI.Search.SearchResultItem).%New() 
    set sitePage.ID = result.Data("ID")
    set sitePage.Description = result.Data("Description") 
    set sitePage.Ingredients = result.Data("Ingredients") 
    set sitePage.RecipeInstructions = result.Data("RecipeInstructions")
    set sitePage.AdditionalData = result.Data("AdditionalData") 
    set sitePage.ImageUrl = result.Data("ImageUrl") 
    set sitePage.SiteId = result.Data("SiteId") 
    set sitePage.URL = result.Data("URL") 
    set sitePage.Keywords = result.Data("Keywords") 
    set sitePage.ModifiedDate = result.Data("ModifiedDate") 
    set sitePage.CreatedDate = result.Data("CreatedDate") 
    set sitePage.RecipeName = result.Data("RecipeName")
    set sitePage.Category = result.Data("Category")
    set sitePage.Rating = result.Data("Rating")
    set sitePage.CommentsCount = result.Data("CommentsCount")
    set sitePage.ClusterIds = result.Data("ClusterIds")
    
    if includeNearest {
		set sitePage.SimilarRecipeWeight = result.Data("SimilarRecipeWeight")   
    }   
       
    return sitePage
]]></Implementation>
</Method>
</Class>


<Class name="RecipeSearch.SearchAPI.Search.SearchResultItem">
<Super>%RegisteredObject</Super>
<TimeChanged>63983,54785.845121</TimeChanged>
<TimeCreated>63689,53434.688769</TimeCreated>

<Property name="ID">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="URL">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="RecipeName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100"/>
</Property>

<Property name="Keywords">
<Type>%Text</Type>
<Parameter name="LANGUAGECLASS" value="%Text.Russian"/>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="ExtendedKeywords">
<Type>%Text</Type>
<Parameter name="LANGUAGECLASS" value="%Text.Russian"/>
<Parameter name="MAXLEN" value="10000"/>
</Property>

<Property name="Description">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="Ingredients">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="RecipeInstructions">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="AdditionalData">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="WordsTfIdf">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="ImageUrl">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="SiteId">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="CreatedDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="ModifiedDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="SimilarRecipeWeight">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="Rating">
<Type>%Integer</Type>
</Property>

<Property name="ClusterIds">
<Type>%String</Type>
<Parameter name="MAXLEN" value="300"/>
</Property>

<Property name="CommentsCount">
<Type>%Integer</Type>
</Property>

<Property name="Category">
<Type>%String</Type>
<Parameter name="MAXLEN" value="300"/>
</Property>
</Class>


<Class name="RecipeSearch.SearchAPI.Search.SitePageResult">
<Super>%RegisteredObject</Super>
<TimeChanged>63808,53966.74658</TimeChanged>
<TimeCreated>63673,70073.256262</TimeCreated>

<Property name="Result">
<Type>RecipeSearch.SearchAPI.Search.SearchResultItem</Type>
</Property>

<Property name="SimilarResults">
<Type>RecipeSearch.SearchAPI.Search.SearchResultItem</Type>
<Collection>list</Collection>
</Property>

<Property name="WordsTFIDF">
<Type>RecipeSearch.SearchAPI.Search.OnlineTfIdf.WordTfIdf</Type>
<Collection>list</Collection>
</Property>
</Class>


<Class name="RecipeSearch.SearchAPI.Suggestion.SuggestionEngine">
<Super>%RegisteredObject</Super>
<TimeChanged>64151,51864.216674</TimeChanged>
<TimeCreated>63640,44078.352651</TimeCreated>

<Method name="SuggestRecipes">
<ClassMethod>1</ClassMethod>
<FormalSpec>query:%String,count:%Integer,spellcheck:%Boolean</FormalSpec>
<Implementation><![CDATA[
	
	if spellcheck {
		set query = ##class(RecipeSearch.Spellcheck.Spellchecker).SpellcheckText(query)
	}
	
	set sqlQuery = "SELECT %NOLOCK TOP "_count 
			_" Keywords,"
			_" SiteId,"
			_" URL,"
			_" RecipeName,"
			_##class(RecipeSearch.SearchAPI.PredicateBuilder).BuildRelevancySubQuery(query)_" AS Relevancy"
		_" FROM RecipeSearch_Data.SitePage sp"
	
	set predicate = ##class(RecipeSearch.SearchAPI.PredicateBuilder).BuildPredicate(query)
	
	if predicate = ""{
		set predicate = "(1 = 0)"
	}
	
	set sqlQuery = sqlQuery_" WHERE "_predicate_" ORDER BY Relevancy DESC, URL, SiteId"
	
	do ##class(%ZEN.Auxiliary.jsonSQLProvider).%WriteJSONFromSQL(,sqlQuery)
]]></Implementation>
</Method>
</Class>


<Class name="RecipeSearch.Spellcheck.SpellcheckDictionaryCreator">
<Super>%RegisteredObject</Super>
<TimeChanged>63983,72970.604096</TimeChanged>
<TimeCreated>63681,75479.498522</TimeCreated>

<Method name="LoadSpellcheckDictionaryFromFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<Implementation><![CDATA[
	
	close filename
	open filename:("RK\CP1251\"):5 if '$test { return 0 }
	
	use filename
	read stringnum
	
	for i=1:1:stringnum {
		read str
		set word = $EXTRACT(str, 9, $LENGTH(str))
		set number = $REPLACE($EXTRACT(str, 1, 7), " ", "")
		set ^SpellcheckDict(word, 1) = number
		set ^SpellcheckDict(word) = 1 // words from dictionary have minimum probability
	}
	
	close filename
	quit 1
]]></Implementation>
</Method>

<Method name="CreateSpellcheckDictionaryFromDB">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	
	set result = ##class(%Library.ResultSet).%New() 
	set tSC = result.Prepare("SELECT Keywords, Ingredients, RecipeInstructions, RecipeName, AdditionalData, Description FROM Data.SitePage") 
    set tSC = result.Execute()
    
    while (result.Next()) 
    {
	    do ##class(RecipeSearch.Spellcheck.SpellcheckDictionaryCreator).AddSitePageData(
	    	result.Data("Keywords"),
	    	result.Data("Ingredients"),
	    	result.Data("RecipeInstructions"),
	    	result.Data("RecipeName"),
	    	result.Data("AdditionalData"),
	    	result.Data("Description")
	    )
    }
]]></Implementation>
</Method>

<Method name="AddSitePageData">
<ClassMethod>1</ClassMethod>
<FormalSpec>keywords:%String,ingredients:%String,instructions:%String,name:%String,additionalData:%String,description:%String</FormalSpec>
<Implementation><![CDATA[
	    
	 //do ##class(RecipeSearch.Spellcheck.SpellcheckDictionaryCreator).AddDataFromText(keywords)	           
	 //do ##class(RecipeSearch.Spellcheck.SpellcheckDictionaryCreator).AddDataFromText(ingredients)	          
	 //do ##class(RecipeSearch.Spellcheck.SpellcheckDictionaryCreator).AddDataFromText(instructions)	    	      
	 do ##class(RecipeSearch.Spellcheck.SpellcheckDictionaryCreator).AddDataFromText(name)        
	 //do ##class(RecipeSearch.Spellcheck.SpellcheckDictionaryCreator).AddDataFromText(additionalData)	    	      
	 //do ##class(RecipeSearch.Spellcheck.SpellcheckDictionaryCreator).AddDataFromText(description)
]]></Implementation>
</Method>

<Method name="AddDataFromText">
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String</FormalSpec>
<Implementation><![CDATA[
	set stemmedList = ##class(RecipeSearch.RecipeAnalyze.StringAnalyzer).GetEntitiesInText(text)	
	do ##class(RecipeSearch.Spellcheck.SpellcheckDictionaryCreator).AddDataFromList(stemmedList)
	
	// TODO: Revisit. Hack to get words list stripped from other symbols
	set orignalWordsList = $LISTFROMSTRING(##class(%iKnow.Stemming.TextStemmer).%New("en").StemWord(text)," ")
	do ##class(RecipeSearch.Spellcheck.SpellcheckDictionaryCreator).AddDataFromList(orignalWordsList)
]]></Implementation>
</Method>

<Method name="AddDataFromList">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemsList:%Library.List</FormalSpec>
<Implementation><![CDATA[
	for i = 1:1:$LISTLENGTH(itemsList){
		set item = $LIST(itemsList, i)
		if item '= ""{
			set ^SpellcheckDict(item) = $GET(^SpellcheckDict(item), 0) + 1
		}
	}
]]></Implementation>
</Method>
</Class>


<Class name="RecipeSearch.Spellcheck.Spellchecker">
<Super>%RegisteredObject</Super>
<TimeChanged>63688,50208.48879</TimeChanged>
<TimeCreated>63681,75436.493578</TimeCreated>

<Method name="SpellcheckText">
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set wordsList = $LISTFROMSTRING(text, " ")
	set resultText = ""

	// try to spellcheck each word
	set length = $LISTLENGTH(wordsList)
	for i=1:1:length{
		set resultText = resultText_##class(RecipeSearch.Spellcheck.Spellchecker).SpellcheckWord($LIST(wordsList, i))
		if i '= length{
			set resultText = resultText_" "
		}		
	}	
	
	return resultText
]]></Implementation>
</Method>

<Method name="SpellcheckWord">
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if $LENGTH(word) < 3{
		return word
	}
	
	if $GET(^SpellcheckDict(word), -1) '= -1{
		return word
	}
	
	set editsList = ##class(RecipeSearch.Spellcheck.Spellchecker).GenerateEdits(word)
	set maxProbability = 0
	set maxProbableWord = word
	
	for i = 1:1:$LISTLENGTH(editsList){
		set probability = $GET(^SpellcheckDict($LIST(editsList,i)), 0)

		if probability > maxProbability{
			set maxProbability = probability
			set maxProbableWord = $LIST(editsList,i)
		}
	}
	
	return maxProbableWord
]]></Implementation>
</Method>

<Method name="GenerateEdits">
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	set resultListItemsCount = 0
	
	set deletions = ##class(RecipeSearch.Spellcheck.Spellchecker).GenerateDeletions(word)
	for i=1:1:$LISTLENGTH(deletions){
		set $LIST(resultList, resultListItemsCount + 1) = $LIST(deletions,i)
		
		set resultListItemsCount = resultListItemsCount + 1
	}
	
	set transpositions = ##class(RecipeSearch.Spellcheck.Spellchecker).GenerateTranspositions(word)
	for i=1:1:$LISTLENGTH(transpositions){
		set $LIST(resultList, resultListItemsCount + 1) = $LIST(transpositions,i)
		
		set resultListItemsCount = resultListItemsCount + 1
	}
	
	set alterations = ##class(RecipeSearch.Spellcheck.Spellchecker).GenerateAlterations(word)
	for i=1:1:$LISTLENGTH(alterations){
		set $LIST(resultList, resultListItemsCount + 1) = $LIST(alterations,i)
		
		set resultListItemsCount = resultListItemsCount + 1
	}
	
	set insertions = ##class(RecipeSearch.Spellcheck.Spellchecker).GenerateInsertions(word)
	for i=1:1:$LISTLENGTH(insertions){
		set $LIST(resultList, resultListItemsCount + 1) = $LIST(insertions,i)
		
		set resultListItemsCount = resultListItemsCount + 1
	}
	
	return resultList
]]></Implementation>
</Method>

<Method name="GenerateDeletions">
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	set length = $LENGTH(word)
	for i = 1:1:length{
		set $LIST(resultList, i) = $EXTRACT(word, 0, i - 1)_$EXTRACT(word, i + 1, length)
	}
	
	return resultList
]]></Implementation>
</Method>

<Method name="GenerateTranspositions">
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	set length = $LENGTH(word)
	for i = 1:1:length{
		set $LIST(resultList, i) = 
		$EXTRACT(word, 0, i - 1) // beginning of string
		_$EXTRACT(word, i + 1, i + 1) // second letter of swap pair
		_$EXTRACT(word, i, i) // first letter of swap pair
		_$EXTRACT(word, i + 2, length) // end  of string
	}
	
	return resultList
]]></Implementation>
</Method>

<Method name="GenerateAlterations">
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	set length = $LENGTH(word)
	set charsList = $LISTBUILD("а","б","в","г","д","е","ё","ж","з","и","й","к","л","м","н","о","п","р","с","т","у","ф","х","ц","ч","щ","ш","ь","ы","ъ","э","ю","я")
	set charsListLength = $LISTLENGTH(charsList)
	set resultListItemsCount = 0
	
	for i = 1:1:length{
		
		for j=1:1:charsListLength{
			if $LIST(charsList, j) '= $EXTRACT(word, i, i){
				set $LIST(resultList, resultListItemsCount + 1) = 
					$EXTRACT(word, 0, i - 1)
					_$LIST(charsList, j)
					_$EXTRACT(word, i + 1, length)
				
				set resultListItemsCount = resultListItemsCount + 1
			}
					
		}		
	}
	
	return resultList
]]></Implementation>
</Method>

<Method name="GenerateInsertions">
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	set length = $LENGTH(word)
	set charsList = $LISTBUILD("а","б","в","г","д","е","ё","ж","з","и","й","к","л","м","н","о","п","р","с","т","у","ф","х","ц","ч","щ","ш","ь","ы","ъ","э","ю","я")
	set charsListLength = $LISTLENGTH(charsList)
	set resultListItemsCount = 0
	
	for i = 1:1:length+1{
		
		for j=1:1:charsListLength{
			if $LIST(charsList, j) '= $EXTRACT(word, i, i){
				set $LIST(resultList, resultListItemsCount + 1) = 
					$EXTRACT(word, 0, i - 1)
					_$LIST(charsList, j)
					_$EXTRACT(word, i, length)
					
				set resultListItemsCount = resultListItemsCount + 1
			}
					
		}		
	}
	
	return resultList
]]></Implementation>
</Method>
</Class>
</Export>
