<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2015.2 (Build 540U)" ts="2015-05-11 22:02:03">
<Class name="%Text.Russian">
<Description><![CDATA[
See <CLASS>%Text.Text</CLASS>
<p>
The <CLASS>%Text.Russian</CLASS> class implements the Russian language-specific lemmatization algorithm,
initializes the language-specific list of noise words and loads Russian morphological dictionary.
<p class=MsoNormal>© Н.А.Шестакова, 2007 </p>
]]></Description>
<Super>%Text.Text</Super>
<TimeChanged>63628,40410.843032</TimeChanged>
<TimeCreated>60696,37781.22329</TimeCreated>

<Parameter name="DEBUG">
<Description><![CDATA[
<PARAMETER>DEBUG</PARAMETER>  #2: включает запись несловарных лемм в ^CacheTempMorpho("PRE",словоформа)=лемма <BR> ]]></Description>
<Default>0</Default>
</Parameter>

<Parameter name="SOURCELANGUAGE">
<Default>ru</Default>
</Parameter>

<Parameter name="DICTIONARY">
<Default>9</Default>
</Parameter>

<Parameter name="NOISEWORDS100">
<Description>
Список шумовых слов (стоп-слов), наиболее часто встречающихся в языке, которые лишь "раздувают" индексы и практически ничего не дают при полнотекстовом поиске. Список взят с http://forum.searchengines.ru/showthread.php?postid=7670 и http://snowball.tartarus.org/algorithms/russian/stop.txt
и несколько модифицирован (добавлены словоформы). На сайте, рекомендованном в описании %Text.Text (http://www.ranks.nl/stopwords/), русский язык отсутствует.</Description>
<Default>а без будто бы быть в вдруг ведь весь во вот впрочем все всегда всего вы г где год да даже два для до должный ее ей если есть еще ж же за зачем здесь и из или им иногда их к каждый как какой ко когда который кто куда лет ли либо между многий много многое можно мой мочь мы на над надо наконец наш не нельзя несколько нет ни нибудь никак никогда ничто но ну о об один однако он она они оно опять от очень перед по под потом потому про раз разве с сам самый свой</Default>
</Parameter>

<Parameter name="NOISEWORDS200">
<Default>себя сегодня сейчас со совсем та так также таки такой там твой те теперь то тогда тоже только тот три ту тут тута ты у уж хороший хорошо хоть хотя чей через что чтоб чтобы чуть этот я</Default>
</Parameter>

<Parameter name="NGRAMLEN">
<Description><![CDATA[
Список шумовых слов (стоп-слов), наиболее часто встречающихся в языке, которые лишь "раздувают" индексы и практически ничего не дают при полнотекстовом поиске. Список взят с http://forum.searchengines.ru/showthread.php?postid=7670 и http://snowball.tartarus.org/algorithms/russian/stop.txt
и несколько модифицирован (добавлены словоформы). На сайте, рекомендованном в описании %Text.Text (http://www.ranks.nl/stopwords/), русский язык отсутствует.
Параметр сознательно установлен в 1, т.к. это открывает возможность поиска словосочетаний, которая теряется при NGRAMLEN>1. Поясню на примере: <br>
SELECT myDocument, myTitle, myPar FROM ft.doc where myDocument %CONTAINS ('челюстно-лицевого')<br>при NGRAMLEN=2 найдет все тексты, содержащие формы слов "челюстный" и "лицевой" в любых комбинациях,<br>
а при NGRAMLEN=1 - лишь те тексты, которые содержат словосочетания, состоящие из форм слов "челюстный" и "лицевой" (вне зависимости от наличия дефиса, который считается разделителем).<br>
Т.е., будут найдены тексты, содержащие "челюстно лицевой", "челюстно-лицевого" и т.д., но не "челюстной нерв лицевого отдела".<br>
Заметим, что возможность поиска всех комбинаций заданных слов по-прежнему сохраняется:<br>
SELECT myDocument, myTitle, myPar FROM ft.doc where myDocument %CONTAINSTERM ('челюстно','лицевого')<br>
При желании вы, конечно, можете задать NGRAMLEN=2, учтите только, что объем индексов при этом существенно возрастет (в разы).]]></Description>
<Default>1</Default>
</Parameter>

<Method name="stemWord">
<Description><![CDATA[
<METHOD>stemWord</METHOD> - метод лемматизации на основе словаря.
<br>На входе: 
<li>b – словоформа</li>
<br>На выходе:
<li>возвращаемое значение (а также параметр b) – лемма</li>
<li>lb - список ($list) всех возможных вариантов лемм, полученных в результате анализа словоформы b.</li>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&b:%String,&lb:%String]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
#; лемматизируем только кириллицу (возможно с дефисами)!
	if ($length(b)<..#MINWORDLEN) || ($translate(b,"абвгдежзийклмнопрстуфхцчшщъыьэюяё-")'="") set lb=$listbuild(b) quit b
	set lem=""
	set lb=""
	set k=$length(b) 
	set b=$translate(b, "ё", "е") ;меняем ё на е
	#; Проверяем наличие слова в словаре
	if $data(^Dict(b)) {
    	for {
    		set lem=$order(^Dict(b, lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($get(^Lemma(lem)))
    		}
		}	
	#; Обработка слов с дефисом
	elseif $length(b, "-")>1 {
		set:($data(^Dict($piece(b, "-", 1)_$piece(b, "-", 2, $length(b, "-"))))) b=..stemWord($piece(b, "-", 1)_$piece(b, "-", 2, $length(b, "-")), .lb)
		quit:(lb'="") b
		set lpart=..stemWord($piece(b, "-", 1), .lp)
		set rpart=..stemWord($piece(b, "-", 2, $length(b, "-")), .rp)
		for i=1:1:$listlength(lp) {
			for j=1:1:$listlength(rp) {
				set lb=lb_$listbuild($list(lp, i)_"-"_$list(rp, j))
				}			
			}
		}
	#; Если не оказалось в словаре, выполняем процедуру предсказания		
	else {	
		set lb=..Prediction(b) 			
		}
    #;set b=lb ; выдаём список лемм для данной словоформы
	set b=$list(lb, $listlength(lb)) ;выдаём последнюю лемму из списка
	quit b
]]></Implementation>
</Method>

<Method name="Prediction">
<Description>
Предсказание незнакомых слов</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&b:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set lb=..Normalword(b)
	if lb="" {
		set lem=""
		set k=$length(b)
		set sc=0 
		for i=2:1:k { ;отсекаем от слова пошагово по букве с начала
			if (i=k-1)&&(sc=0)&&(..ends(b, k, 2, "ой", .j)) {
				set lb=lb_$listbuild($extract(b, 1, j))
				set sc=1
				}
			if (i=k)&&(sc=0)&&(..ends(b, k, 1, "о", .j)) {
				set lb=lb_$listbuild(b)
				set sc=1
				}
			quit:(sc=1)
			set stemend=$extract(b, i-1, i-1)
			if ..cons(stemend)=1 {
				set cons="cons"
				}
			elseif ..cons(stemend)=0 {
				set cons="vow"
				}	
			set psfl=$extract(b, i, k)
			if $data(^Predict(cons, psfl))=10 {
				for {
					set lem=$order(^Predict(cons, psfl, lem))
					quit:(lem="")
					set fl=$get(^Predict(cons, psfl, lem))
					if fl="#" {
						set fl=""
						}
					set lb=lb_$listbuild($extract(b, 1, i-1)_fl)
					}
				set sc=1					
				}
			}
		if (sc=0) { // окончание пустое! // &&(..ends(b, k, 0, "",.j)) {
			set lb=lb_$listbuild(b)
			}
		}
#if ..#DEBUG#2
	set ^CacheTempMorpho("PRE",b)=lb
#endif
    quit lb
]]></Implementation>
</Method>

<Method name="cons">
<Description>
Процедура проверки, является ли буква согласной</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>k</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	quit:("аеёиоуыэюяАЕЁИОУЫЭЮЯ#"[k) 0
	quit 1
]]></Implementation>
</Method>

<Method name="Normalword">
<Description>
Процедура проверки, имеет ли слово продуктивный префикс или продуктивный суффикс</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>b</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set lem=""
	set lb=""
	set k=$length(b)
	set j=""
	if (($extract(b, 1, 2)="не")||($extract(b, 1, 2)="ре")||($extract(b, 1, 2)="за")||($extract(b, 1, 2)="до")||($extract(b, 1, 2)="де")||($extract(b, 1, 2)="по"))&&(k'=2)&&(($data(^Dict($extract(b, 3, k))))) {
	    for {
    		set lem=$order(^Dict($extract(b, 3, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($extract(b, 1, 2)_$get(^Lemma(lem)))
    		}
    	set b=lb	
	    quit b
	}
	if (($extract(b, 1, 3)="суб")||($extract(b, 1, 3)="нео")||($extract(b, 1, 3)="без")||($extract(b, 1, 3)="меж")||($extract(b, 1, 3)="дез")||($extract(b, 1, 3)="пан")||($extract(b, 1, 3)="пра")||($extract(b, 1, 3)="все")||($extract(b, 1, 3)="вне")||($extract(b, 1, 3)="дис")||($extract(b, 1, 3)="бес")||($extract(b, 1, 3)="дву"))&&(k'=3)&&(($data(^Dict($extract(b, 4, k))))) {
	    for {
    		set lem=$order(^Dict($extract(b, 4, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($extract(b, 1, 3)_$get(^Lemma(lem)))
    		}
    	set b=lb	
	    quit b
	}
	if (($extract(b, 1, 4)="анти")||($extract(b, 1, 4)="обще")||($extract(b, 1, 4)="пост")||($extract(b, 1, 4)="пред")||($extract(b, 1, 4)="полу")||($extract(b, 1, 4)="пере")||($extract(b, 1, 4)="само")||($extract(b, 1, 4)="поли")||($extract(b, 1, 4)="одно")||($extract(b, 1, 4)="архи")||($extract(b, 1, 4)="пара")||($extract(b, 1, 4)="недо")||($extract(b, 1, 4)="мета")||($extract(b, 1, 4)="мало")||($extract(b, 1, 4)="мини")||($extract(b, 1, 4)="гипо")||($extract(b, 1, 4)="двух")||($extract(b, 1, 4)="грам")||($extract(b, 1, 4)="пери"))&&(k'=4)&&(($data(^Dict($extract(b, 5, k))))) {
	    for {
    		set lem=$order(^Dict($extract(b, 5, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($extract(b, 1, 4)_$get(^Lemma(lem)))
    		}
    	set b=lb
	    quit b
	}
	if (($extract(b, 1, 5)="после")||($extract(b, 1, 5)="небез")||($extract(b, 1, 5)="микро")||($extract(b, 1, 5)="контр")||($extract(b, 1, 5)="сверх")||($extract(b, 1, 5)="квази")||($extract(b, 1, 5)="супер")||($extract(b, 1, 5)="много")||($extract(b, 1, 5)="макро")||($extract(b, 1, 5)="гипер")||($extract(b, 1, 5)="разно")||($extract(b, 1, 5)="около")||($extract(b, 1, 5)="низко")||($extract(b, 1, 5)="интер"))&&(k'=5)&&(($data(^Dict($extract(b, 6, k))))) {
	    for {
    		set lem=$order(^Dict($extract(b, 6, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($extract(b, 1, 5)_$get(^Lemma(lem)))
    		}
    	set b=lb
	    quit b
	}
	if (($extract(b,1,6)="псевдо")||($extract(b,1,6)="ультра")||($extract(b,1,6)="внутри")||($extract(b,1,6)="экстра")||($extract(b,1,6)="мульти")||($extract(b,1,6)="энтеро"))&&(k'=6)&&(($data(^Dict($extract(b, 7, k))))) {
	    for {
    		set lem=$order(^Dict($extract(b, 7, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($extract(b, 1, 6)_$get(^Lemma(lem)))
    		}
    	set b=lb
	    quit b
	}
	if ($extract(b,1,7)="противо")&&(k'=7)&&(($data(^Dict($extract(b, 8, k))))) {
		for {
    		set lem=$order(^Dict($extract(b, 8, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($extract(b, 1, 7)_$get(^Lemma(lem)))
    		}
    	set b=lb
	    quit b
	}
	if ..ends(b, k, 4, "ость", .j)||..ends(b, k, 4, "ости", .j)||..ends(b, k, 5, "остью", .j)||..ends(b, k, 5, "остей", .j)||..ends(b, k, 5, "остям", .j)||..ends(b, k, 6, "остями", .j)||..ends(b, k, 5, "остях", .j) {
		set b=lb_$listbuild($extract(b, 1, j)_"ость")
		quit b
	}
	if ..ends(b, k, 4, "тель", .j)||..ends(b, k, 4, "теля", .j)||..ends(b, k, 4, "телю", .j)||..ends(b, k, 5, "телем", .j)||..ends(b, k, 4, "теле", .j)||..ends(b, k, 4, "тели", .j)||..ends(b, k, 5, "телей", .j)||..ends(b, k, 5, "телям", .j)||..ends(b, k, 6, "телями", .j)||..ends(b, k, 5, "телях", .j) {
		set b=lb_$listbuild($extract(b, 1, j)_"тель")
		quit b
	}
	if ..ends(b, k, 4, "ство", .j)||..ends(b, k, 4, "ства", .j)||..ends(b, k, 4, "ству", .j)||..ends(b, k, 5, "ством", .j)||..ends(b, k, 4, "стве", .j)||..ends(b, k, 4, "ства", .j)||..ends(b, k, 3, "ств", .j)||..ends(b, k, 5, "ствам", .j)||..ends(b, k, 6, "ствами", .j)||..ends(b, k, 5, "ствах", .j) {
		set b=lb_$listbuild($extract(b, 1, j)_"ство")
		quit b
	}
	if ..ends(b, k, 2, "ий", .j)||..ends(b, k, 3, "ого", .j)||..ends(b, k, 3, "ому", .j)||..ends(b, k, 2, "им", .j)||..ends(b, k, 2, "ом", .j)||..ends(b, k, 2, "ое", .j)||..ends(b, k, 2, "ая", .j)||..ends(b, k, 2, "ой", .j)||..ends(b, k, 2, "ую", .j)||..ends(b, k, 2, "ие", .j)||..ends(b, k, 2, "их", .j)||..ends(b, k, 2, "им", .j)||..ends(b, k, 3, "ими", .j) {
		if ($extract(b, j)="к") {
		    set b=lb_$listbuild($extract(b, 1, j)_"ий")
		    quit b
		}
	}
	if ..ends(b, k, 2, "ий", .j)||..ends(b, k, 3, "его", .j)||..ends(b, k, 3, "ему", .j)||..ends(b, k, 2, "им", .j)||..ends(b, k, 2, "ем", .j)||..ends(b, k, 2, "ее", .j)||..ends(b, k, 2, "ая", .j)||..ends(b, k, 2, "ей", .j)||..ends(b, k, 2, "ую", .j)||..ends(b, k, 2, "ие", .j)||..ends(b, k, 2, "их", .j)||..ends(b, k, 2, "им", .j)||..ends(b, k, 3, "ими", .j) {
		if ($extract(b, j-1, j)="ющ")||($extract(b, j-1, j)="ящ")||($extract(b, j-1, j)="ущ")||($extract(b, j-1, j)="ащ") {
		    set b=lb_$listbuild($extract(b, 1, j)_"ий")
		    quit b
		}
	}
	if ..ends(b, k, 2, "ия", .j)||..ends(b, k, 2, "ии", .j)||..ends(b, k, 2, "ию", .j)||..ends(b, k, 3, "ией", .j)||..ends(b, k, 2, "ий", .j)||..ends(b, k, 3, "иям", .j)||..ends(b, k, 4, "иями", .j)||..ends(b, k, 3, "иях", .j)||..ends(b, k, 2, "ие", .j)||..ends(b, k, 3, "ием", .j) {
		if ($extract(b,j-2, j)="фоб")||($extract(b, j)="г")||($extract(b,j-1, j)="ид")||($extract(b, j)="з")||($extract(b, j)="к")||($extract(b,j-2, j)="фил")||($extract(b, j)="м")||($extract(b,j-2, j)="ман")||($extract(b,j-1, j)="оп")||($extract(b,j-5, j)="бактер")||($extract(b,j-3, j)="метр")||($extract(b,j-1, j)="ур")||($extract(b, j)="с")||($extract(b, j-2,j)="пат")||($extract(b,j-3, j)="дент")||($extract(b, j)="ф")||($extract(b, j)="х")||($extract(b, j)="ц") {
		    set b=lb_$listbuild($extract(b, 1, j)_"ия")
		    quit b
			}
		if ($extract(b,j-1, j)="ан")||($extract(b, j-1, j)="ен")||($extract(b, j-2, j)="ств") {
			set b=lb_$listbuild($extract(b, 1, j)_"ие")
			quit b
			}
		else {
			set b=lb_$listbuild($extract(b, 1, j)_"ия")
			quit b
		}
	}
	if ..ends(b, k, 1, "а", .j)||..ends(b, k, 2, "ом", .j)||..ends(b, k, 1, "е", .j)||..ends(b, k, 1, "ы", .j)||..ends(b, k, 2, "ов", .j)||..ends(b, k, 2, "ам", .j)||..ends(b, k, 3, "ами", .j)||..ends(b, k, 2, "ах", .j)||..ends(b, k, 2, "ой", .j)||..ends(b, k, 2, "ей", .j) {
		if ($extract(b, j-1, j)="ид")||($extract(b, j-1, j)="аз")||($extract(b, j-1, j)="ез")||($extract(b, j-1, j)="оз")||($extract(b, j-1, j)="ал")||($extract(b, j-1, j)="ил")||($extract(b, j-1, j)="ол")||($extract(b, j-2, j)="изм")||($extract(b, j-1, j)="ан")||($extract(b, j-1, j)="ен")||($extract(b, j-2, j)="ген")||($extract(b, j-1, j)="ин")||($extract(b, j-4, j)="штейн")||($extract(b, j-1, j)="он")||($extract(b, j-2, j)="сон")||($extract(b, j-3, j)="скоп")||($extract(b, j-1, j)="ер")||($extract(b, j-2, j)="тор")||($extract(b, j-1, j)="ат")||($extract(b, j-1, j)="ит")||($extract(b, j-2, j)="ист") {
		#;if ($e(b, j-1, j)="ид")||($e(b, j-1, j)="аз")||($e(b, j-1, j)="ёз")||($e(b, j-1, j)="ез")||($e(b, j-1, j)="оз")||($e(b, j-1, j)="ал")||($e(b, j-1, j)="ил")||($e(b, j-1, j)="ол")||($e(b, j-2, j)="изм")||($e(b, j-1, j)="ан")||($e(b, j-1, j)="ен")||($e(b, j-2, j)="ген")||($e(b, j-1, j)="ин")||($e(b, j-4, j)="штейн")||($e(b, j-1, j)="он")||($e(b, j-2, j)="сон")||($e(b, j-3, j)="скоп")||($e(b, j-1, j)="ер")||($e(b, j-1, j)="ёр")||($e(b, j-2, j)="тор")||($e(b, j-1, j)="ат")||($e(b, j-1, j)="ит")||($e(b, j-2, j)="ист") {
			set b=lb_$listbuild($extract(b, 1, j))
			quit b
		}
		if ($extract(b,j-1,j)="ом")||($extract(b,j-1,j)="ем")||($extract(b,j-2,j)="азм")||($extract(b, j-4, j)="грамм")||($extract(b,j-1,j)="иц") {
		#;if ($e(b,j-1,j)="ом")||($e(b,j-1,j)="ём")||($e(b,j-1,j)="ем")||($e(b,j-2,j)="азм")||($e(b, j-4, j)="грамм")||($e(b,j-1,j)="иц") {			
			set b=lb_$listbuild($extract(b, 1, j)_"а")
			quit b
		}
	}
	if ..ends(b, k, 1, "а", .j)||..ends(b, k, 2, "ом", .j)||..ends(b, k, 1, "е", .j)||..ends(b, k, 2, "ов", .j)||..ends(b, k, 2, "ам", .j)||..ends(b, k, 3, "ами", .j)||..ends(b, k, 2, "ах", .j)||..ends(b, k, 2, "ой", .j)||..ends(b, k, 2, "ей", .j)||..ends(b, k, 1, "и",.j) {
		if ($extract(b, j-2, j)="инг")||($extract(b, j-3, j)="берг")||($extract(b, j-1, j)="ик") {
			set b=lb_$listbuild($extract(b, 1, j))
			quit b
		}
	}
	if ..ends(b, k, 2, "ея", .j)||..ends(b, k, 2, "еи", .j)||..ends(b, k, 2, "ею", .j)||..ends(b, k, 3, "еей", .j)||..ends(b, k, 2, "ей", .j)||..ends(b, k, 3, "еям", .j)||..ends(b, k, 4, "еями", .j)||..ends(b, k, 3, "еях", .j)||..ends(b, k, 2, "ее", .j) {
		if ($extract(b, j)="р") {
		    set b=lb_$listbuild($extract(b, 1, j)_"ея")
		    quit b
		}
	}
	if ..ends(b, k, 2, "ый", .j)||..ends(b, k, 3, "ого", .j)||..ends(b, k, 3, "ому", .j)||..ends(b, k, 2, "ым", .j)||..ends(b, k, 2, "ом", .j)||..ends(b, k, 2, "ое", .j)||..ends(b, k, 2, "ая", .j)||..ends(b, k, 2, "ой", .j)||..ends(b, k, 2, "ую", .j)||..ends(b, k, 2, "ые", .j)||..ends(b, k, 2, "ых", .j)||..ends(b, k, 2, "ым", .j)||..ends(b, k, 3, "ыми", .j) {
		if ($extract(b, j-1,j)="ов")||($extract(b, j)="н")||($extract(b, j-2,j)="ист") {
		    set b=lb_$listbuild($extract(b, 1, j)_"ый")
		    quit b
		}
	}
	if ..ends(b, k, 1, "у", .j)||..ends(b, k, 0, "",.j) {
		if ($extract(b, j-2, j)="инг")||($extract(b, j-3, j)="берг")||($extract(b, j-1, j)="ид")||($extract(b, j-1, j)="аз")||($extract(b, j-1, j)="ез")||($extract(b, j-1, j)="оз")||($extract(b, j-1, j)="ик")||($extract(b, j-1, j)="ал")||($extract(b, j-1, j)="ил")||($extract(b, j-1, j)="ол")||($extract(b, j-2, j)="изм")||($extract(b, j-1, j)="ан")||($extract(b, j-1, j)="ен")||($extract(b, j-2, j)="ген")||($extract(b, j-1, j)="ин")||($extract(b, j-4, j)="штейн")||($extract(b, j-1, j)="он")||($extract(b, j-2, j)="сон")||($extract(b, j-3, j)="скоп")||($extract(b, j-1, j)="ер")||($extract(b, j-2, j)="тор")||($extract(b, j-1, j)="ат")||($extract(b, j-1, j)="ит")||($extract(b, j-2, j)="ист") {
		#;if ($e(b, j-2, j)="инг")||($e(b, j-3, j)="берг")||($e(b, j-1, j)="ид")||($e(b, j-1, j)="аз")||($e(b, j-1, j)="ёз")||($e(b, j-1, j)="ез")||($e(b, j-1, j)="оз")||($e(b, j-1, j)="ик")||($e(b, j-1, j)="ал")||($e(b, j-1, j)="ил")||($e(b, j-1, j)="ол")||($e(b, j-2, j)="изм")||($e(b, j-1, j)="ан")||($e(b, j-1, j)="ен")||($e(b, j-2, j)="ген")||($e(b, j-1, j)="ин")||($e(b, j-4, j)="штейн")||($e(b, j-1, j)="он")||($e(b, j-2, j)="сон")||($e(b, j-3, j)="скоп")||($e(b, j-1, j)="ер")||($e(b, j-1, j)="ёр")||($e(b, j-2, j)="тор")||($e(b, j-1, j)="ат")||($e(b, j-1, j)="ит")||($e(b, j-2, j)="ист") {
			set b=lb_$listbuild($extract(b, 1, j))
			quit b
		}
		if ($extract(b,j-1,j)="ом")||($extract(b,j-1,j)="ем")||($extract(b,j-2,j)="азм")||($extract(b, j-4, j)="грамм")||($extract(b,j-1,j)="иц") {
		#;if ($e(b,j-1,j)="ом")||($e(b,j-1,j)="ём")||($e(b,j-1,j)="ем")||($e(b,j-2,j)="азм")||($e(b, j-4, j)="грамм")||($e(b,j-1,j)="иц") {
			set b=lb_$listbuild($extract(b, 1, j)_"а")
			quit b
		}
	}			
	quit ""
]]></Implementation>
</Method>

<Method name="LoadDict">
<Description><![CDATA[
<METHOD>LoadDict</METHOD> - метод загрузки грамматического словаря из файла
<br>На входе:
<li>filename - полный путь к файлу словаря (http://www.aot.ru/download.php, Морф. словарь (русск.)) </li>
<br>На выходе:
<li>1 - успех, 0 - не удалось открыть файл.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	set sc=..readDictionary(filename, .number)
 	if sc=1 { 
 		do ..inflections(filename)
 		do ..dictionarize(number)
 	}
 	quit sc
]]></Implementation>
</Method>

<Method name="readDictionary">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[filename:%String,&number]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^CacheTempPdgm1
	kill ^CacheTempA1
	close filename
	open filename:("RK\CP1251\"):5 if '$test { quit 0 }
		use filename
		read stringnum
		for i=1:1:stringnum {
			read str
			set ^CacheTempPdgm1(i)=..formatstr2(str)
			}
		
		do {			
			read str
			} while '(str?6N) 
		if str?6N {
			set number=str	
			for i=1:1:number {
				read str
				set ^CacheTempA1(i)=..formatstr(str)
			}
		}
	close filename
	quit 1
]]></Implementation>
</Method>

<Method name="formatstr">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
 ;делаем из леммы список словоформ
	set string=$zconvert(string ,"L")
	set pdgm=$piece(string, " ",2)+1
	set plist=^CacheTempPdgm1(pdgm)
	set l=$listlength(plist) ;отбрасываем #
	for j=1:1:l {
		set $list(lstring, j)=$piece(string, " ",1) _ $list(plist, j)
		if ($extract($list(lstring, j))="#")&&($extract($list(lstring, j), 2)'="") { 
		set k=$list(lstring, j) 
		set $extract(k)=""
		set $list(lstring, j)=k 
		}
		}
	quit lstring
]]></Implementation>
</Method>

<Method name="formatstr2">
<ClassMethod>1</ClassMethod>
<FormalSpec>string</FormalSpec>
<Private>1</Private>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
 ; строку парадигмы приводим к списку окончаний
	set string=$zconvert(string ,"L")
	set lstring=$length(string, "*")
	set paradigm=""
	for j=1:1:lstring {
		if $find($piece(string, "*", j), "%")'=0 {
			set paradigm=paradigm_$listbuild($piece($piece(string, "*", j), "%", 2))
		}
		
		}
	quit paradigm
]]></Implementation>
</Method>

<Method name="dictionarize">
<ClassMethod>1</ClassMethod>
<FormalSpec>number</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
 ;все слова в своём глобале, словоформы в своём, 
 ;С УЧЁТОМ ГРАММАТИЧЕСКОЙ НЕОДНОЗНАЧНОСТИ.
	kill ^Lemma
	kill ^Dict
	if ($sortbegin(^Lemma)) {}
	if ($sortbegin(^Dict)) {}
	for i=1:1:number {
		set wlist=^CacheTempA1(i)
		set ^Lemma(i)=$list(wlist, 1)
		set b=$listlength(wlist)
		for j=1:1:b {
			set ^Dict($translate($list(wlist, j), "ё","е"),i)=""
			}
	}
	if ($sortend(^Lemma)) {}
	if ($sortend(^Dict)) {}
	kill ^CacheTempPdgm1
	kill ^CacheTempA1
]]></Implementation>
</Method>

<Method name="inflections">
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
	kill ^Predict ;глобал для предсказания
	if ($sortbegin(^Predict)) {}
	close filename
	open filename:("RK\CP1251\")
		use filename
		do {			
			read str
			} while '(str?6N) 
		if str?6N {
			set number=str	
			for i=1:1:number {
				read str
				set stem=$piece(str, " ", 1)
				set l=$length(stem)
				set k=$piece(str, " ", 2)
				if ..cons($extract(stem, l))=1 {		
					if $data(a(k))=0 {
						set a(k)=1
						set array(i)=k
						set letter(k)="cons"
						}
					else {
						set b=$get(a(k))
						set a(k)=b+1
						if letter(k)="vow" {
							set letter(k)="letter"
							}
						}
					}
				elseif ..cons($extract(stem, l))=0 {		
					if $data(a(k))=0 {
						set a(k)=1
						set array(i)=k
						set letter(k)="vow"
						}
					else {
						set b=$get(a(k))
						set a(k)=b+1
						if letter(k)="cons" {
							set letter(k)="letter"
							}
						}
					}
				}
			}
	close filename
	for i=1:1:number {
		set m=$get(array(i))
		if $data(array(i))'=0, a(m)>247, letter(m)="cons"||"letter" {
			set plist=$get(^CacheTempPdgm1(m+1))
			set b=$listlength(plist)
			for j=1:1:b {
				if $list(plist, j)="" {
					set $list(plist, j)="#"
					}
				}			
			for j=1:1:b {
				set d=$list(plist, 1)
				set u=$list(plist, j)
				set t=""			
				for {
					set sc=0
					set t=$order(^Predict("cons", u, t))
					quit:(t="")
					if $get(^Predict("cons", u,t))=d, t<(a(m)) {
						set ^Predict("cons", u, a(m))=d
						kill ^Predict("cons", u,t)
						set sc=1
						quit
						}
					elseif $get(^Predict("cons", u,t))=d, t>=(a(m)) {
						set sc=1
						quit
						}
					}
				if sc=0 {
					set ^Predict("cons", u, a(m))=d
					}
				}
			}
		if $data(array(i))'=0, a(m)>247, letter(m)="vow"||"letter" {
			set plist=$get(^CacheTempPdgm1(m+1))
			set b=$listlength(plist)
			for j=1:1:b {
				if $list(plist, j)="" {
					set $list(plist, j)="#"
					}
				}			
			for j=1:1:b {
				set d=$list(plist, 1)
				set u=$list(plist, j)
				set t=""			
				for {
					set sc=0
					set t=$order(^Predict("vow", u, t))
					quit:(t="")
					if $get(^Predict("vow", u,t))=d, t<(a(m)) {
						set ^Predict("vow", u, a(m))=d
						kill ^Predict("vow", u,t)
						set sc=1
						quit
						}
					elseif $get(^Predict("vow", u,t))=d, t>=(a(m)) {
						set sc=1
						quit
						}
					}
				if sc=0 {
					set ^Predict("vow", u, a(m))=d
					}
				}
			}
 		}
	if ($sortend(^Predict)) {}
]]></Implementation>
</Method>
</Class>


<Class name="Data.Base.Entity">
<Super>%Persistent</Super>
<TimeChanged>63611,44290.858824</TimeChanged>
<TimeCreated>63610,79980.536971</TimeCreated>

<Property name="CreatedDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="ModifiedDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="IsActive">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Data.Base.EntityD</DataLocation>
<DefaultData>EntityDefaultData</DefaultData>
<IdLocation>^Data.Base.EntityD</IdLocation>
<IndexLocation>^Data.Base.EntityI</IndexLocation>
<StreamLocation>^Data.Base.EntityS</StreamLocation>
<Data name="EntityDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CreatedDate</Value>
</Value>
<Value name="3">
<Value>ModifiedDate</Value>
</Value>
<Value name="4">
<Value>IsActive</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Data.Config">
<Super>Data.Base.Entity</Super>
<TimeChanged>63681,78966.645546</TimeChanged>
<TimeCreated>63610,79444.886551</TimeCreated>

<Property name="LoggingEnabled">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="EnhancedKeywordProcessing">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="MaxPagesToCrawl">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="MaxCrawlDepth">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="MaxConcurrentThreads">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="CrawlTimeoutSeconds">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="EnableSpellcheckDictionaryUpdate">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ConfigDefaultData</DefaultData>
<Data name="ConfigDefaultData">
<Subscript>"Config"</Subscript>
<Value name="1">
<Value>LoggingEnabled</Value>
</Value>
<Value name="2">
<Value>EnhancedKeywordProcessing</Value>
</Value>
<Value name="3">
<Value>MaxPagesToCrawl</Value>
</Value>
<Value name="4">
<Value>MaxCrawlDepth</Value>
</Value>
<Value name="5">
<Value>CrawlTimeoutSeconds</Value>
</Value>
<Value name="6">
<Value>EnableSpellcheckDictionaryUpdate</Value>
</Value>
<Value name="7">
<Value>MaxConcurrentThreads</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Data.CrawlingHistoryItem">
<Super>Data.Base.Entity</Super>
<TimeChanged>63611,45537.303607</TimeChanged>
<TimeCreated>63610,86227.669281</TimeCreated>

<Property name="SiteId">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="StardDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="EndDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="CrawledPagesCount">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="IsStopped">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<ForeignKey name="SiteToCrawl">
<Properties>SiteId</Properties>
<ReferencedClass>Data.SiteToCrawl</ReferencedClass>
</ForeignKey>

<Method name="ClearAllHistory">
<ClassMethod>1</ClassMethod>
<Language>tsql</Language>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[	UPDATE Data.CrawlingHistoryItem SET IsActive = 0
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>CrawlingHistoryItemDefaultData</DefaultData>
<Data name="CrawlingHistoryItemDefaultData">
<Subscript>"CrawlingHistoryItem"</Subscript>
<Value name="1">
<Value>SiteId</Value>
</Value>
<Value name="2">
<Value>StardDate</Value>
</Value>
<Value name="3">
<Value>EndDate</Value>
</Value>
<Value name="4">
<Value>CrawledPagesCount</Value>
</Value>
<Value name="5">
<Value>IsStopped</Value>
</Value>
</Data>
</Storage>
</Class>


<Package name="Data" sqlname="Data"/>


<Class name="Data.RecipeData.WordsTF">
<Super>%Persistent</Super>
<TimeChanged>63683,74641.170853</TimeChanged>
<TimeCreated>63683,65238.598919</TimeCreated>

<Property name="RecipeId">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="Word">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="200"/>
</Property>

<Property name="TF">
<Type>%Double</Type>
<Required>1</Required>
</Property>

<Property name="WordCount">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<ForeignKey name="SitePage">
<Properties>RecipeId</Properties>
<ReferencedClass>Data.SitePage</ReferencedClass>
</ForeignKey>

<Index name="MainIDX">
<PrimaryKey>1</PrimaryKey>
<Properties>RecipeId,Word</Properties>
</Index>

<Index name="WordIDX">
<Properties>Word</Properties>
</Index>

<Method name="ComputeWordsTF">
<ClassMethod>1</ClassMethod>
<FormalSpec>RecipeId:%Integer,Keywords:%String(MAXLEN=1000),RecipeName:%String(MAXLEN=100),Description:%String(MAXLEN=100000),Ingredients:%String(MAXLEN=100000),RecipeInstructions:%String(MAXLEN=100000),AdditionalData:%String(MAXLEN=100000)</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	write "enter","-",RecipeId,"-",Keywords,!
	
	set extendedKeywords = 
		RecipeName_"; "_Description_"; "_Ingredients
		_"; "_RecipeInstructions_"; "_AdditionalData
		
	set extendedKeywordsList = ##class(RecipeAnalyze.StringAnalyzer).GetEntitiesInText(extendedKeywords)
	set extendedKeywordsCountList = $LISTFROMSTRING("")
	set extendedKeywords = ""
	
	set maxCount = -1
	set length = $LISTLENGTH(extendedKeywordsList)
	
	for i=1:1:length{
		set word = $LIST(extendedKeywordsList, i)
		
		if word = ""{
			set extendedKeywordsCountList = extendedKeywordsCountList_$LISTBUILD("")
			continue
		}
		
		set extendedKeywords = extendedKeywords_" "_word
		
		set count = 1
		for j=i+1:1:length{
			if $LIST(extendedKeywordsList,j) = word{
				set $LIST(extendedKeywordsList,j) = ""
				set count = count + 1
			}
		}
		
		if count > maxCount{
			set maxCount = count
		}
		
		set extendedKeywordsCountList = extendedKeywordsCountList_$LISTBUILD(count)		
	}
	
	&sql(UPDATE Data.SitePage SET ExtendedKeywords = :extendedKeywords WHERE Id = :RecipeId)
	&sql(DELETE FROM Data_RecipeData.WordsTF WHERE RecipeId = :RecipeId)
	
	for i=1:1:length{
		set word = $LIST(extendedKeywordsList, i)
		set wordCount = $LIST(extendedKeywordsCountList, i)
		
		if word = ""{
			continue
		}
		
		set wordTf = 0.5 + 0.5 * wordCount / maxCount
		
		&sql(INSERT INTO Data_RecipeData.WordsTF
			(RecipeId, Word, TF, WordCount)
			VALUES(:RecipeId, :word, :wordTf, :wordCount))
	}
]]></Implementation>
</Method>

<Method name="ComputeWordsTFForAllRecipes">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	&sql(declare recipesCursor cursor for
	      select ID, Keywords, RecipeName, Description, Ingredients, RecipeInstructions,AdditionalData
          from Data.SitePage)
          
    &sql(open recipesCursor)
    for {
	   &sql(fetch recipesCursor into :curID,:Keywords,:RecipeName,:Description,:Ingredients,:RecipeInstructions, :AdditionalData)
	   quit:(SQLCODE '= 0)

	   do ##class(Data.RecipeData.WordsTF).ComputeWordsTF(curID, Keywords, RecipeName, Description, Ingredients, RecipeInstructions, AdditionalData)
    }
    &sql(close recipesCursor)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Data.RecipeData.WordsTFD</DataLocation>
<DefaultData>WordsTFDefaultData</DefaultData>
<IdLocation>^Data.RecipeData.WordsTFD</IdLocation>
<IndexLocation>^Data.RecipeData.WordsTFI</IndexLocation>
<StreamLocation>^Data.RecipeData.WordsTFS</StreamLocation>
<Data name="WordsTFDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>RecipeId</Value>
</Value>
<Value name="3">
<Value>Word</Value>
</Value>
<Value name="4">
<Value>TF</Value>
</Value>
<Value name="5">
<Value>Count</Value>
</Value>
<Value name="6">
<Value>WordCount</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Data.SearchSettings">
<Super>Data.Base.Entity</Super>
<TimeChanged>63650,75279.792166</TimeChanged>
<TimeCreated>63610,79681.607063</TimeCreated>

<Property name="ResultsOnPage">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="SuggestionsCount">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="EnableSpellchecking">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Property name="EnableSpellcheckingForSuggest">
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>SearchSettingsDefaultData</DefaultData>
<Data name="SearchSettingsDefaultData">
<Subscript>"SearchSettings"</Subscript>
<Value name="1">
<Value>ResultsOnPage</Value>
</Value>
<Value name="2">
<Value>SuggestionsCount</Value>
</Value>
<Value name="3">
<Value>EnableSpellchecking</Value>
</Value>
<Value name="4">
<Value>EnableSpellcheckingForSuggest</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Data.SitePage">
<Super>%Persistent</Super>
<TimeChanged>63683,77306.952918</TimeChanged>
<TimeCreated>63581,84906.169887</TimeCreated>

<Property name="URL">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="RecipeName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100"/>
</Property>

<Property name="Keywords">
<Type>%Text</Type>
<Parameter name="LANGUAGECLASS" value="%Text.Russian"/>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="ExtendedKeywords">
<Type>%Text</Type>
<Parameter name="LANGUAGECLASS" value="%Text.Russian"/>
<Parameter name="MAXLEN" value="10000"/>
</Property>

<Property name="Description">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="Ingredients">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="RecipeInstructions">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="AdditionalData">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="WordsTfIdf">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="NearestResults">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="ImageUrl">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="SiteId">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="CreatedDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Property name="ModifiedDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<ForeignKey name="SiteToCrawl">
<Properties>SiteId</Properties>
<ReferencedClass>Data.SiteToCrawl</ReferencedClass>
</ForeignKey>

<Index name="MainIDX">
<PrimaryKey>1</PrimaryKey>
<Properties>SiteId,URL</Properties>
</Index>

<Index name="KeywordsIDX">
<Properties>ExtendedKeywords(KEYS)</Properties>
</Index>

<Index name="RecipeUQIDX">
<Properties>SiteId,RecipeName</Properties>
<Unique>1</Unique>
</Index>

<Method name="Upsert">
<ClassMethod>1</ClassMethod>
<FormalSpec>URL:%String(MAXLEN=255),Keywords:%String(MAXLEN=1000),RecipeName:%String(MAXLEN=100),Description:%String(MAXLEN=100000),Ingredients:%String(MAXLEN=100000),RecipeInstructions:%String(MAXLEN=100000),AdditionalData:%String(MAXLEN=100000),ImageUrl:%String(MAXLEN=2000),SiteId:%Integer,ProcessKeywords:%Boolean,UpdateSpellcheckDict:%Boolean</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	IF ProcessKeywords{
		set keywordsList = ##class(RecipeAnalyze.StringAnalyzer).GetEntitiesInText(Keywords)
		set keywordsAnalyzed = ""
		set listLength = $LISTLENGTH(keywordsList)
		for i=1:1:listLength {		
			set keyword = $LIST(keywordsList, i)
			
			set keywordsAnalyzed = keywordsAnalyzed_" "_$LIST(keywordsList, i)
		}
	}	
	ELSE {
		set keywordsAnalyzed = Keywords
	}
	
	IF UpdateSpellcheckDict{
		do ##class(Spellcheck.SpellcheckDictionaryCreator).AddSitePageData(
			Keywords,
			Ingredients,
			RecipeInstructions,
			RecipeName,
			AdditionalData,
			Description)
	}

	do ##class(Data.SitePage).UpsertSQL(URL, keywordsAnalyzed, RecipeName, Description,Ingredients,RecipeInstructions,AdditionalData, ImageUrl, SiteId)
]]></Implementation>
</Method>

<Method name="UpsertSQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>URL:%String(MAXLEN=255),Keywords:%String(MAXLEN=1000),RecipeName:%String(MAXLEN=100),Description:%String(MAXLEN=100000),Ingredients:%String(MAXLEN=100000),RecipeInstructions:%String(MAXLEN=100000),AdditionalData:%String(MAXLEN=100000),ImageUrl:%String(MAXLEN=2000),SiteId:%Integer</FormalSpec>
<Language>tsql</Language>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	IF EXISTS(SELECT * FROM SitePage WHERE URL = @URL AND SiteId = @SiteId) THEN BEGIN
		UPDATE SitePage SET 
			AdditionalData = @AdditionalData,
			Description = @Description,
			Ingredients = @Ingredients,
			RecipeInstructions = @RecipeInstructions, 
			Keywords = @Keywords, 
			RecipeName = @RecipeName, 
			ImageUrl = @ImageUrl, 
			ModifiedDate = GETUTCDATE()
		WHERE URL = @URL AND SiteId = @SiteId;
	END ELSE BEGIN
		INSERT INTO SitePage(SiteId, URL, Description,Ingredients,RecipeInstructions,AdditionalData,ImageUrl, Keywords,RecipeName, CreatedDate, ModifiedDate) 
		VALUES(@SiteId, @URL, @Description,@Ingredients,@RecipeInstructions,@AdditionalData,@ImageUrl, @Keywords, @RecipeName, GETUTCDATE(), GETUTCDATE());
	END
	GO 

	DECLARE @RecipeId AS INT;
	SET @RecipeId = (SELECT TOP 1 Id FROM SitePage WHERE URL = @URL AND SiteId = @SiteId ORDER BY ID)
	
	exec Data_RecipeData.WordsTF_ComputeWordsTF 
		@RecipeId = @RecipeId, 
		@Keywords = @Keywords, 
		@RecipeName = @Keywords,
		@Description = @Description,
		@Ingredients = @Ingredients,
		@RecipeInstructions = @RecipeInstructions,
		@AdditionalData = @AdditionalData
]]></Implementation>
</Method>

<Method name="DeleteRecordsForSiteId">
<ClassMethod>1</ClassMethod>
<FormalSpec>SiteId:%Integer</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	&sql(DELETE %NOLOCK FROM Data_RecipeData.WordsTF 
		WHERE RecipeId IN (SELECT Id FROM data.SitePage WHERE SiteID = :SiteId))
	&sql(DELETE %NOLOCK FROM SitePage WHERE SiteID = :SiteId)
]]></Implementation>
</Method>

<Method name="DeleteSitesRecords">
<ClassMethod>1</ClassMethod>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	&sql(DELETE %NOLOCK FROM Data_RecipeData.WordsTF)
	&sql(DELETE %NOLOCK FROM SitePage)
]]></Implementation>
</Method>

<Query name="GetRecordsBySiteId">
<Type>%SQLQuery</Type>
<SqlName>SitePage_GetRecordsBySiteId</SqlName>
<SqlProc>1</SqlProc>
<SqlQuery>SELECT SiteId AS SiteId, COUNT(*) AS PageCount
FROM SitePage
GROUP BY SiteId</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Query name="GetTFIDF">
<Type>%SQLQuery</Type>
<SqlName>SitePage_GetTFIDF</SqlName>
<SqlProc>1</SqlProc>
<SqlQuery>SELECT ID, WordsTfIdf FROM SitePage</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Method name="UpdateNearestResults">
<ClassMethod>1</ClassMethod>
<FormalSpec>PageId:%Integer,NearestResults:%String</FormalSpec>
<Language>tsql</Language>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
		
		UPDATE SitePage SET NearestResults = @NearestResults WHERE Id = @PageId
]]></Implementation>
</Method>

<Query name="GetTFIDFStatistic">
<Type>%SQLQuery</Type>
<SqlName>SitePage_GetTFIDFStatistic</SqlName>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT COUNT(*) AS EmptyTfIdf from data.SitePage WHERE WordsTfIdf IS NULL OR WordsTfIdf = ''</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Query name="GetNearestResultsStatistic">
<Type>%SQLQuery</Type>
<SqlName>SitePage_GetNearestResultsStatistic</SqlName>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT COUNT(*) AS EmptyNearestResults from data.SitePage WHERE NearestResults IS NULL OR NearestResults = ''</SqlQuery>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="SELECTMODE" value="RUNTIME"/>
</Query>

<Method name="UpdateTfIdf">
<ClassMethod>1</ClassMethod>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[	do ##class(RecipeAnalyze.PageAnalyzer).CountTfIdf()
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Data.SitePageD</DataLocation>
<DefaultData>SitePageDefaultData</DefaultData>
<IdLocation>^Data.SitePageD</IdLocation>
<IndexLocation>^Data.SitePageI</IndexLocation>
<StreamLocation>^Data.SitePageS</StreamLocation>
<Data name="SitePageDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>URL</Value>
</Value>
<Value name="3">
<Value>Content</Value>
</Value>
<Value name="4">
<Value>Keywords</Value>
</Value>
<Value name="5">
<Value>SiteId</Value>
</Value>
<Value name="6">
<Value>CreatedDate</Value>
</Value>
<Value name="7">
<Value>ModifiedDate</Value>
</Value>
<Value name="8">
<Value>RecipeName</Value>
</Value>
<Value name="9">
<Value>Description</Value>
</Value>
<Value name="10">
<Value>Ingredients</Value>
</Value>
<Value name="11">
<Value>RecipeInstructions</Value>
</Value>
<Value name="12">
<Value>AdditionalData</Value>
</Value>
<Value name="13">
<Value>WordsTfIdf</Value>
</Value>
<Value name="14">
<Value>NearestResults</Value>
</Value>
<Value name="15">
<Value>ImageUrl</Value>
</Value>
<Value name="16">
<Value>ExtendedKeywords</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Data.SiteToCrawl">
<Super>Data.Base.Entity</Super>
<TimeChanged>63619,69539.191074</TimeChanged>
<TimeCreated>63610,79732.940998</TimeCreated>

<Property name="Name">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="URL">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="ConfigId">
<Type>%Integer</Type>
</Property>

<Property name="ParserId">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100"/>
</Property>

<ForeignKey name="Config">
<Properties>ConfigId</Properties>
<ReferencedClass>Data.Config</ReferencedClass>
</ForeignKey>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>SiteToCrawlDefaultData</DefaultData>
<Data name="SiteToCrawlDefaultData">
<Subscript>"SiteToCrawl"</Subscript>
<Value name="1">
<Value>Name</Value>
</Value>
<Value name="2">
<Value>URL</Value>
</Value>
<Value name="3">
<Value>ConfigId</Value>
</Value>
<Value name="4">
<Value>ParserId</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Data.Utils.Seed">
<Super>%RegisteredObject</Super>
<TimeChanged>63681,75519.735878</TimeChanged>
<TimeCreated>63611,44219.144767</TimeCreated>

<Method name="Run">
<ClassMethod>1</ClassMethod>
<Language>tsql</Language>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	// Seed crawler config
	IF NOT EXISTS(SELECT * FROM Data.Config) THEN BEGIN
		INSERT INTO Data.Config(LoggingEnabled, EnhancedKeywordProcessing, EnableSpellcheckDictionaryUpdate, MaxPagesToCrawl, MaxConcurrentThreads, MaxCrawlDepth, CrawlTimeoutSeconds, IsActive, CreatedDate, ModifiedDate) 
		VALUES(0, 1, 1, 100000, 10, 100000, 0, 1, GETUTCDATE(), GETUTCDATE());
		
		DECLARE @ConfigId AS INT;
		SELECT TOP 1 @ConfigId = Id FROM Data.Config;

		// Seed sites to crawl		
		INSERT INTO Data.SiteToCrawl(Name, URL, ConfigId, ParserId, IsActive, CreatedDate, ModifiedDate) 
		VALUES('say7', 'http://www.say7.info/', @ConfigId, 'RecipeSchema', 1, GETUTCDATE(), GETUTCDATE());
		INSERT INTO Data.SiteToCrawl(Name, URL, ConfigId,ParserId, IsActive, CreatedDate, ModifiedDate) 
		VALUES('edimdoma', 'http://www.edimdoma.ru/', @ConfigId,'EdimDoma', 1, GETUTCDATE(), GETUTCDATE());
		INSERT INTO Data.SiteToCrawl(Name, URL, ConfigId,ParserId, IsActive, CreatedDate, ModifiedDate) 
		VALUES('kedem', 'http://kedem.ru/', @ConfigId,'RecipeSchema', 1, GETUTCDATE(), GETUTCDATE());
		INSERT INTO Data.SiteToCrawl(Name, URL, ConfigId,ParserId, IsActive, CreatedDate, ModifiedDate) 
		VALUES('gotovim-doma', 'http://gotovim-doma.ru/', @ConfigId,'GotovimDoma', 1, GETUTCDATE(), GETUTCDATE());
		INSERT INTO Data.SiteToCrawl(Name, URL, ConfigId,ParserId, IsActive, CreatedDate, ModifiedDate) 
		VALUES('koolinar', 'http://www.koolinar.ru', @ConfigId,'Kulinar', 1, GETUTCDATE(), GETUTCDATE());
		END
	
	// Delete crawling history
	DELETE FROM Data.CrawlingHistoryItem
	
	// Seed search settings
	IF NOT EXISTS(SELECT * FROM Data.SearchSettings) THEN BEGIN
		INSERT INTO Data.SearchSettings(ResultsOnPage, SuggestionsCount,EnableSpellchecking,EnableSpellcheckingForSuggest, IsActive, CreatedDate, ModifiedDate) 
		VALUES(25, 10, 1, 1, 1, GETUTCDATE(), GETUTCDATE());
	END
]]></Implementation>
</Method>

<Method name="LoadDictionaries">
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	
	do ##class(%Text.Russian).LoadDict(directory_"\morphs.mrd")
	
	kill ^SpellcheckDict
	do ##class(Spellcheck.SpellcheckDictionaryCreator).LoadSpellcheckDictionaryFromFile(directory_"\spellcheck.txt")
	do ##class(Spellcheck.SpellcheckDictionaryCreator).CreateSpellcheckDictionaryFromDB()
	do ##class(Data.Utils.Seed).ReadRecipesDictionaryToGlobal(directory_"\dictionary.txt")
]]></Implementation>
</Method>

<Method name="ReadRecipesDictionaryToGlobal">
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<Implementation><![CDATA[
	kill ^allDict
	
	close filename
	open filename:("RK\CP1251\"):5 if '$test { return 0 }
	
	use filename	   
    read stringnum
	
	for i=1:1:stringnum {
		read word
		set ^allDict(word) = 1
	}
	
	close filename
	quit 1
]]></Implementation>
</Method>
</Class>


<Class name="Logging.LogRecord">
<Super>%Persistent</Super>
<TimeChanged>63682,64488.949431</TimeChanged>
<TimeCreated>63611,44722.841798</TimeCreated>

<Property name="Type">
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="Description">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="Exception">
<Type>%String</Type>
<Parameter name="MAXLEN" value="10000"/>
</Property>

<Property name="CreatedDate">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Logging.LogRecordD</DataLocation>
<DefaultData>LogRecordDefaultData</DefaultData>
<IdLocation>^Logging.LogRecordD</IdLocation>
<IndexLocation>^Logging.LogRecordI</IndexLocation>
<StreamLocation>^Logging.LogRecordS</StreamLocation>
<Data name="LogRecordDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>MaxPagesToCrawl</Value>
</Value>
<Value name="3">
<Value>Description</Value>
</Value>
<Value name="4">
<Value>Exception</Value>
</Value>
<Value name="5">
<Value>CreatedDate</Value>
</Value>
<Value name="6">
<Value>Type</Value>
</Value>
</Data>
</Storage>
</Class>


<Package name="Logging" sqlname="Logging"/>


<Class name="RecipeAnalyze.PageAnalyzer">
<Super>%RegisteredObject</Super>
<TimeChanged>63683,76339.972944</TimeChanged>
<TimeCreated>63681,75947.377003</TimeCreated>

<Method name="AddWordsToGlobal">
<ClassMethod>1</ClassMethod>
<FormalSpec>words:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set wordsStemmed = ##class(RecipeAnalyze.StringAnalyzer).StemText(words)
	set wordList = $LISTFROMSTRING(wordsStemmed, " ")
	for i=1:1:$listlength(wordList) {
		set curWord = $list(wordList,i)
		set inDictionary = $GET(^allDict(curWord))
		if inDictionary '= "" {
			set curFrequency = $GET(^tempWords(curWord))
			if curFrequency '= "" {
				set ^tempWords(curWord) = curFrequency + 1
			} else {
				set ^tempWords(curWord) = 1
			}
		}
	}
]]></Implementation>
</Method>

<Method name="CountTfIdf">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^documentFrequency
	kill ^tempWords
	kill ^tf
	kill ^maxtf
	#sqlcompile SELECT = odbc
	&sql(declare byalldata cursor for
	      select ID,Keywords, RecipeName, Ingredients, RecipeInstructions
          from Data.SitePage)
    &sql(open byalldata)
    set numberOfDocuments = 0
    for {
	   &sql(fetch byalldata into :curID,:Keywords,:RecipeName,:Ingredients,:RecipeInstructions)
	   quit:(SQLCODE '= 0)
	   set numberOfDocuments = numberOfDocuments + 1 
	   do ##class(RecipeAnalyze.PageAnalyzer).AddWordsToGlobal(Keywords)
	   do ##class(RecipeAnalyze.PageAnalyzer).AddWordsToGlobal(RecipeName)
	   do ##class(RecipeAnalyze.PageAnalyzer).AddWordsToGlobal(Ingredients)
	   do ##class(RecipeAnalyze.PageAnalyzer).AddWordsToGlobal(RecipeInstructions)

	   set termFrequency = ""
	   set maxFrequency = 0
	   set key = $Order(^tempWords(""))
	   while key '= "" {
		   set curFrequency = $GET(^tempWords(key))
		   set allFrequency = $GET(^documentFrequency(key))
		   if allFrequency = "" {
			   set ^documentFrequency(key) = 1
		   } else {
			   set ^documentFrequency(key) = allFrequency + 1
		   }
		   if curFrequency > maxFrequency {
			   set maxFrequency = curFrequency
		   }
		   set termFrequency = termFrequency_key_","_curFrequency_" "
		   set key = $Order(^tempWords(key))
	   }
	   set ^tf(curID) = termFrequency
	   set ^maxtf(curID) = maxFrequency
	   kill ^tempWords
	   
	   // &sql(update data.SitePage set AdvancedKeywords = :enhancedKeywords where ID = :ID)
    }
    &sql(close byalldata)
    
    &sql(declare byURL cursor for
	      select ID,URL
	      from Data.SitePage)
    &sql(open byURL)
    for {
	   &sql(fetch byURL into :curID,:curURL)
	   quit:(SQLCODE '= 0)
	   set termFrequency = $GET(^tf(curID))
	   set maxFrequency = $GET(^maxtf(curID))
	   set frequencyList = $LISTFROMSTRING(termFrequency, " ")
	   set documentTfIdf = ""
	   for i=1:1:$listlength(frequencyList)-1 {
		   set curGroup = $list(frequencyList,i)
		   set curWord = $PIECE(curGroup, ",", 1)
		   set curFrequency = $PIECE(curGroup, ",", 2)
		   set curDocumentFrequency = ^documentFrequency(curWord)
		   set curIdf = $ZLN(numberOfDocuments / curDocumentFrequency)
		   set curTf = (0.5 * curFrequency / maxFrequency) + 0.5
		   set curTfIdf = curTf * curIdf
		   set documentTfIdf = documentTfIdf_curWord_","_curTfIdf_" "
	   }
	   &sql(update data.SitePage set WordsTfIdf = :documentTfIdf where ID = :curID)
    }
    &sql(close byURL)
]]></Implementation>
</Method>

<Method name="CalculateTfIdf">
<ClassMethod>1</ClassMethod>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	kill ^globalIdf
	
	&sql(select COUNT(DISTINCT RecipeId) into :totoalNumberOfDocuments from Data_RecipeData.WordsTF)
	
	&sql(declare wordsCursor cursor for
	      select LCASE(Word), COUNT(Word) as DocumentsCount from Data_RecipeData.WordsTF GROUP BY Word)        
    &sql(open wordsCursor)
    for {
	   &sql(fetch wordsCursor into :word,:documentsCount)
	   quit:(SQLCODE '= 0)

	   set ^globalIdf(word) = $ZLN(totoalNumberOfDocuments / documentsCount)
    }
    &sql(close wordsCursor)
    
    &sql(declare recipesCursor cursor for
	      select id from Data.SitePage)        
    &sql(open recipesCursor)
    for {
	   	&sql(fetch recipesCursor into :recipeId)
	   	quit:(SQLCODE '= 0)

		set documentTfIdf = ""
		
	   	&sql(declare recipeWordsCursor cursor for select Word, TF from Data_RecipeData.WordsTF WHERE RecipeId = :recipeId) 
	   	&sql(open recipeWordsCursor)
    	for {
	   		&sql(fetch recipeWordsCursor into :word, :tf)
	   		quit:(SQLCODE '= 0)
	   		
	   		if $GET(^globalIdf(word), -1) = -1{
				continue
			}
	   		
	   		set tfidf = tf * ^globalIdf(word)
	   		set documentTfIdf = documentTfIdf_word_","_tfidf_" "
    	}
    	&sql(close recipeWordsCursor) 
    	
    	&sql(update data.SitePage SET WordsTfIdf = :documentTfIdf WHERE Id = :recipeId) 	      
    }
    &sql(close recipesCursor)
]]></Implementation>
</Method>
</Class>


<Class name="RecipeAnalyze.StringAnalyzer">
<TimeChanged>63681,75995.758964</TimeChanged>
<TimeCreated>63610,80153.007685</TimeCreated>

<Method name="GetEntitiesInText">
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String</FormalSpec>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	set words = ##class(RecipeAnalyze.StringAnalyzer).StemText(text) 
	return $LISTFROMSTRING(words, " ")
]]></Implementation>
</Method>

<Method name="StemText">
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set stemmer = ##class(%iKnow.Stemming.TextStemmer).%New("ru")
	return stemmer.StemWord(text)
]]></Implementation>
</Method>
</Class>


<Project name="RecipesSearch" LastModified="2015-05-11 21:21:02.774494">
  <Items>
    <ProjectItem name="%Text.Russian" type="CLS"></ProjectItem>
    <ProjectItem name="Data" type="PKG"></ProjectItem>
    <ProjectItem name="Logging" type="PKG"></ProjectItem>
    <ProjectItem name="RecipeAnalyze.PageAnalyzer" type="CLS"></ProjectItem>
    <ProjectItem name="RecipeAnalyze.StringAnalyzer" type="CLS"></ProjectItem>
    <ProjectItem name="SearchAPI.PredicateBuilder" type="CLS"></ProjectItem>
    <ProjectItem name="SearchAPI.RESTBroker" type="CLS"></ProjectItem>
    <ProjectItem name="SearchAPI.Search.SearchEngine" type="CLS"></ProjectItem>
    <ProjectItem name="SearchAPI.Search.SearchResult" type="CLS"></ProjectItem>
    <ProjectItem name="SearchAPI.Search.SitePageResult" type="CLS"></ProjectItem>
    <ProjectItem name="SearchAPI.Suggestion.SuggestionEngine" type="CLS"></ProjectItem>
    <ProjectItem name="Spellcheck.SpellcheckDictionaryCreator" type="CLS"></ProjectItem>
    <ProjectItem name="Spellcheck.Spellchecker" type="CLS"></ProjectItem>
  </Items>
</Project>


<Class name="SearchAPI.PredicateBuilder">
<Super>%RegisteredObject</Super>
<TimeChanged>63683,79176.197995</TimeChanged>
<TimeCreated>63640,44416.350546</TimeCreated>

<Method name="BuildPredicate">
<ClassMethod>1</ClassMethod>
<FormalSpec>query:%String</FormalSpec>
<Implementation><![CDATA[
	
	set queryParts = ##class(RecipeAnalyze.StringAnalyzer).GetEntitiesInText(query)
	
	set predicate = ""
	set i = 1
	set listLength = $LISTLENGTH(queryParts)
	
	IF listLength = 0 {
		return predicate
	}
	
	set predicate = "ExtendedKeywords %CONTAINS("
	
	for i=1:1:listLength{
		if i '= 1{
			set predicate = predicate_", "
		}
		
		set predicate = predicate_"'"_$LIST(queryParts, i)_"'"
	}
	
	set predicate = predicate_")"
	
	return predicate
]]></Implementation>
</Method>

<Method name="BuildRelevancySubQuery">
<ClassMethod>1</ClassMethod>
<FormalSpec>query:%String</FormalSpec>
<Implementation><![CDATA[
	
	set queryParts = ##class(RecipeAnalyze.StringAnalyzer).GetEntitiesInText(query)
	
	set subquery = ""
	set i = 1
	set listLength = $LISTLENGTH(queryParts)
	
	IF listLength = 0 {
		return subquery
	}
	
	set subquery = "("
	
	for i=1:1:listLength{
		set word = $LIST(queryParts, i)
		
		if $GET(^globalIdf(word), -1) = -1{
			continue
		}
		
		if i '= 1{
			set subquery = subquery_" + "
		}
										
		set subquery = subquery_"(SELECT SUM(TF)* "_^globalIdf(word)_" from Data_RecipeData.WordsTF WHERE RecipeId = sp.Id AND word = '"_word_"')"
	}
	
	set subquery = subquery_") AS Relevancy"
	
	return subquery
]]></Implementation>
</Method>
</Class>


<Class name="SearchAPI.RESTBroker">
<Super>%CSP.REST</Super>
<TimeChanged>63681,76503.316604</TimeChanged>
<TimeCreated>63584,64787.957361</TimeCreated>

<XData name="UrlMap">
<Data><![CDATA[
<Routes>
 <Route Url="/doSearch" Method="GET" Call="Search"/>
 <Route Url="/suggest" Method="GET" Call="Suggest"/>
 </Routes>
]]></Data>
</XData>

<Method name="Search">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set query = %request.Get("query", "")
	set pageNumber = %request.Get("pageNumber", "1")
	set pageSize = %request.Get("pageSize", "25")
	
	set spellcheck = %request.Get("spellcheck", 0)
	set exactMatch = %request.Get("exactMatch", 0) // ignore spellchecking result
	
	try {
    	do ##class(SearchAPI.Search.SearchEngine).SearchPages(query, spellcheck, exactMatch, pageNumber, pageSize)
	} catch err {
    	write err.AsSystemError()
    }
		
	quit $$$OK
]]></Implementation>
</Method>

<Method name="Suggest">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set query = %request.Get("query", "")
	set count = %request.Get("count", "10")
	set spellcheck = %request.Get("spellcheck", 0)
	
	try {
    	do ##class(SearchAPI.Suggestion.SuggestionEngine).SuggestRecipes(query, count, spellcheck)
	} catch err {
    	write err.AsSystemError()
    }
		
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="SearchAPI.Search.SearchEngine">
<Super>%RegisteredObject</Super>
<TimeChanged>63683,78813.27533</TimeChanged>
<TimeCreated>63598,70157.596857</TimeCreated>

<Method name="SearchPages">
<ClassMethod>1</ClassMethod>
<FormalSpec>query:%String,spellcheck:%Boolean,exactMatch:%Boolean,pageNumber:%Integer,pageSize:%Integer</FormalSpec>
<Implementation><![CDATA[
	set sqlQuery = "SELECT %NOLOCK" 
			_" ID,"
			_" Description,"
			_" Ingredients,"
			_" RecipeInstructions,"
			_" AdditionalData,"
			_" ImageUrl,"
			_" Keywords,"
			_" SiteId,"
			_" URL,"
			_" RecipeName, "
			_" NearestResults,"
			_##class(SearchAPI.PredicateBuilder).BuildRelevancySubQuery(query)_","
			_" CreatedDate," 
			_" ModifiedDate"
		_" FROM Data.SitePage sp"
	
	if spellcheck {
		set spellcheckedQuery = ##class(Spellcheck.Spellchecker).SpellcheckText(query)
		
		if 'exactMatch{
			set query = spellcheckedQuery
		}
	}
	
	set predicate = ##class(SearchAPI.PredicateBuilder).BuildPredicate(query)
	
	set sqlQuery = sqlQuery_" WHERE "_predicate_" ORDER BY Relevancy DESC, URL, SiteId"	
		
	set result = ##class(%Library.ResultSet).%New() 
	set tSC = result.Prepare(sqlQuery) 
    set tSC = result.Execute()
     
    set searchResult = ##class(SearchAPI.Search.SearchResult).PopulateFromResultSet(result, pageNumber, pageSize)           
	
	if spellcheck{
		set searchResult.SpellcheckedQuery = spellcheckedQuery
	}
		
	do ##class(%ZEN.Auxiliary.jsonProvider).%ObjectToJSON(searchResult)
]]></Implementation>
</Method>
</Class>


<Class name="SearchAPI.Search.SearchResult">
<Super>%RegisteredObject</Super>
<TimeChanged>63681,58741.559997</TimeChanged>
<TimeCreated>63627,74813.171587</TimeCreated>

<Property name="Items">
<Type>SearchAPI.Search.SitePageResult</Type>
<Collection>list</Collection>
</Property>

<Property name="TotalCount">
<Type>%Integer</Type>
</Property>

<Property name="PageNumber">
<Type>%Integer</Type>
</Property>

<Property name="SpellcheckedQuery">
<Type>%String</Type>
</Property>

<Method name="PopulateFromResultSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>result:%Library.ResultSet,pageNumber:%Integer,pageSize:%Integer</FormalSpec>
<ReturnType>%Library.ResultSet</ReturnType>
<Implementation><![CDATA[
	
	// TODO: make it more performant
	set startIndex = (pageNumber - 1) * pageSize + 1
	
	set searchResults = ##class(SearchAPI.Search.SearchResult).%New()
	set searchResults.Items = ##class(%ListOfObjects).%New()
	
	set count = 0
    while (result.Next()) 
    { 
    	set count = count + 1 
		continue:(count < startIndex) 
        
        if (count >= (startIndex + pageSize)) 
        {  
			continue
        } 
        
        set sitePageResult = ##class(SearchAPI.Search.SitePageResult).%New()
        
        set sitePageResult.Result = ##class(SearchAPI.Search.SearchResult).MapResultToSitePage(result)
        set sitePageResult.SimilarResults = ##class(SearchAPI.Search.SearchResult).GetSimilarResults(sitePageResult.Result.NearestResults)
              
        set tSC = searchResults.Items.Insert(sitePageResult) 
        
	}
    
   	set searchResults.PageNumber = pageNumber
	set searchResults.TotalCount = count
	
	return searchResults
]]></Implementation>
</Method>

<Method name="GetSimilarResults">
<ClassMethod>1</ClassMethod>
<FormalSpec>NearestResults:%String</FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<Implementation><![CDATA[
	set similarResultsObjects = ##class(%ListOfObjects).%New()
	
   	set similarResultsIds = $LISTFROMSTRING(NearestResults, " ")            
   	set length = $LISTLENGTH(similarResultsIds)
   	
   	if length = 0{
	   	return similarResultsObjects
   	}

   	set sqlQuery = "SELECT %NOLOCK ID, Description,Ingredients,RecipeInstructions,AdditionalData,ImageUrl,Keywords,SiteId,URL,RecipeName, NearestResults, CreatedDate, ModifiedDate"
   	_" FROM Data.SitePage WHERE ID IN ("
   	
   	for i=1:1:length{
	   	if $LIST(similarResultsIds, i) = ""{
	      	continue
      	}
   		if i '= 1{
       		set sqlQuery = sqlQuery_", "
      	}
     	set sqlQuery = sqlQuery_$LIST(similarResultsIds, i)
    }
    set sqlQuery = sqlQuery_")"
    
    set result = ##class(%Library.ResultSet).%New() 
	set tSC = result.Prepare(sqlQuery) 
    set tSC = result.Execute()
    
    set actulaIdsOrder = $LISTFROMSTRING("")
    
    while (result.Next()) 
    {
	    set similarResult = ##class(SearchAPI.Search.SearchResult).MapResultToSitePage(result)
	    do similarResultsObjects.Insert(similarResult)
	    
	    set id = result.Data("ID")	    	
	    set actulaIdsOrder = actulaIdsOrder_$LISTBUILD(id)
	    
    }   
    
    // Order results by distance
    set similarResultsObjectsOrdered = ##class(%ListOfObjects).%New()
    
    set actualResultsLength = $LISTLENGTH(actulaIdsOrder)
    
    for i=1:1:length{
	    set id = $LIST(similarResultsIds, i)
	    
	    if id = ""{
	      	continue
      	}
	    
	    for j=1:1:actualResultsLength{
		   if $LIST(actulaIdsOrder, j) = id{
			    do similarResultsObjectsOrdered.Insert(similarResultsObjects.GetAt(j))
		    }
	    }
    }
			    
    return similarResultsObjectsOrdered
]]></Implementation>
</Method>

<Method name="MapResultToSitePage">
<ClassMethod>1</ClassMethod>
<FormalSpec>result:%Library.ResultSet</FormalSpec>
<ReturnType>Data.SitePage</ReturnType>
<Implementation><![CDATA[
	set sitePage = ##class(Data.SitePage).%New() 
    set sitePage.Description = result.Data("Description") 
    set sitePage.Ingredients = result.Data("Ingredients") 
    set sitePage.RecipeInstructions = result.Data("RecipeInstructions")
    set sitePage.AdditionalData = result.Data("AdditionalData") 
    set sitePage.ImageUrl = result.Data("ImageUrl") 
    set sitePage.SiteId = result.Data("SiteId") 
    set sitePage.URL = result.Data("URL") 
    set sitePage.Keywords = result.Data("Keywords") 
    set sitePage.ModifiedDate = result.Data("ModifiedDate") 
    set sitePage.CreatedDate = result.Data("CreatedDate") 
    set sitePage.RecipeName = result.Data("RecipeName") 
    set sitePage.NearestResults = result.Data("NearestResults") 
       
    return sitePage
]]></Implementation>
</Method>
</Class>


<Class name="SearchAPI.Search.SitePageResult">
<Super>%RegisteredObject</Super>
<TimeChanged>63673,75886.369848</TimeChanged>
<TimeCreated>63673,70073.256262</TimeCreated>

<Property name="Result">
<Type>Data.SitePage</Type>
</Property>

<Property name="SimilarResults">
<Type>Data.SitePage</Type>
<Collection>list</Collection>
</Property>
</Class>


<Class name="SearchAPI.Suggestion.SuggestionEngine">
<Super>%RegisteredObject</Super>
<TimeChanged>63683,79248.650103</TimeChanged>
<TimeCreated>63640,44078.352651</TimeCreated>

<Method name="SuggestRecipes">
<ClassMethod>1</ClassMethod>
<FormalSpec>query:%String,count:%Integer,spellcheck:%Boolean</FormalSpec>
<Implementation><![CDATA[
	
	set sqlQuery = "SELECT %NOLOCK TOP "_count 
			_" Keywords,"
			_" SiteId,"
			_" URL,"
			_" RecipeName,"
			_##class(SearchAPI.PredicateBuilder).BuildRelevancySubQuery(query)
		_" FROM Data.SitePage sp"
	
	if spellcheck {
		set query = ##class(Spellcheck.Spellchecker).SpellcheckText(query)
	}
	
	set predicate = ##class(SearchAPI.PredicateBuilder).BuildPredicate(query)
	
	if predicate = ""{
		set predicate = "(1 = 0)"
	}
	set sqlQuery = sqlQuery_" WHERE "_predicate_" ORDER BY Relevancy DESC, URL, SiteId"
	
	do ##class(%ZEN.Auxiliary.jsonSQLProvider).%WriteJSONFromSQL(,sqlQuery)
]]></Implementation>
</Method>
</Class>


<Class name="Spellcheck.SpellcheckDictionaryCreator">
<Super>%RegisteredObject</Super>
<TimeChanged>63681,81044.462611</TimeChanged>
<TimeCreated>63681,75479.498522</TimeCreated>

<Method name="LoadSpellcheckDictionaryFromFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<Implementation><![CDATA[
	
	close filename
	open filename:("RK\CP1251\"):5 if '$test { return 0 }
	
	use filename
	read stringnum
	
	for i=1:1:stringnum {
		read str
		set word = $EXTRACT(str, 9, $LENGTH(str))
		set number = $REPLACE($EXTRACT(str, 1, 7), " ", "")
		set ^SpellcheckDict(word, 1) = number
		set ^SpellcheckDict(word) = 1 // words from dictionary have minimum probability
	}
	
	close filename
	quit 1
]]></Implementation>
</Method>

<Method name="CreateSpellcheckDictionaryFromDB">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	
	set result = ##class(%Library.ResultSet).%New() 
	set tSC = result.Prepare("SELECT Keywords, Ingredients, RecipeInstructions, RecipeName, AdditionalData, Description FROM Data.SitePage") 
    set tSC = result.Execute()
    
    while (result.Next()) 
    {
	    do ##class(Spellcheck.SpellcheckDictionaryCreator).AddSitePageData(
	    	result.Data("Keywords"),
	    	result.Data("Ingredients"),
	    	result.Data("RecipeInstructions"),
	    	result.Data("RecipeName"),
	    	result.Data("AdditionalData"),
	    	result.Data("Description")
	    )
    }
]]></Implementation>
</Method>

<Method name="AddSitePageData">
<ClassMethod>1</ClassMethod>
<FormalSpec>keywords:%String,ingredients:%String,instructions:%String,name:%String,additionalData:%String,description:%String</FormalSpec>
<Implementation><![CDATA[
	    
	 do ##class(Spellcheck.SpellcheckDictionaryCreator).AddDataFromText(keywords)	           
	 do ##class(Spellcheck.SpellcheckDictionaryCreator).AddDataFromText(ingredients)	          
	 do ##class(Spellcheck.SpellcheckDictionaryCreator).AddDataFromText(instructions)	    	      
	 do ##class(Spellcheck.SpellcheckDictionaryCreator).AddDataFromText(name)        
	 do ##class(Spellcheck.SpellcheckDictionaryCreator).AddDataFromText(additionalData)	    	      
	 do ##class(Spellcheck.SpellcheckDictionaryCreator).AddDataFromText(description)
]]></Implementation>
</Method>

<Method name="AddDataFromText">
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String</FormalSpec>
<Implementation><![CDATA[
	set stemmedList = ##class(RecipeAnalyze.StringAnalyzer).GetEntitiesInText(text)	
	do ##class(Spellcheck.SpellcheckDictionaryCreator).AddDataFromList(stemmedList)
	
	// TODO: Revisit. Hack to get words list stripped from other symbols
	set orignalWordsList = $LISTFROMSTRING(##class(%iKnow.Stemming.TextStemmer).%New("en").StemWord(text)," ")
	do ##class(Spellcheck.SpellcheckDictionaryCreator).AddDataFromList(orignalWordsList)
]]></Implementation>
</Method>

<Method name="AddDataFromList">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemsList:%Library.List</FormalSpec>
<Implementation><![CDATA[
	for i = 1:1:$LISTLENGTH(itemsList){
		set item = $LIST(itemsList, i)
		if item '= ""{
			set ^SpellcheckDict(item) = $GET(^SpellcheckDict(item), 0) + 1
		}
	}
]]></Implementation>
</Method>
</Class>


<Class name="Spellcheck.Spellchecker">
<Super>%RegisteredObject</Super>
<TimeChanged>63681,75772.571092</TimeChanged>
<TimeCreated>63681,75436.493578</TimeCreated>

<Method name="SpellcheckText">
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set wordsList = $LISTFROMSTRING(text, " ")
	set resultText = ""
	
	// try to spellcheck each word
	set length = $LISTLENGTH(wordsList)
	for i=1:1:length{
		set resultText = resultText_##class(Spellcheck.Spellchecker).SpellcheckWord($LIST(wordsList, i))
		if i '= length{
			set resultText = resultText_" "
		}		
	}	
	
	return resultText
]]></Implementation>
</Method>

<Method name="SpellcheckWord">
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if $GET(^SpellcheckDict(word), -1) '= -1{
		return word
	}
	
	set editsList = ##class(Spellcheck.Spellchecker).GenerateEdits(word)
	
	set maxProbability = 0
	set maxProbableWord = word
	
	for i = 1:1:$LISTLENGTH(editsList){
		set probability = $GET(^SpellcheckDict($LIST(editsList,i)), 0)

		if probability > maxProbability{
			set maxProbability = probability
			set maxProbableWord = $LIST(editsList,i)
		}
	}
	
	return maxProbableWord
]]></Implementation>
</Method>

<Method name="GenerateEdits">
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	set resultListItemsCount = 0
	
	set deletions = ##class(Spellcheck.Spellchecker).GenerateDeletions(word)
	for i=1:1:$LISTLENGTH(deletions){
		set $LIST(resultList, resultListItemsCount + 1) = $LIST(deletions,i)
		
		set resultListItemsCount = resultListItemsCount + 1
	}
	
	set transpositions = ##class(Spellcheck.Spellchecker).GenerateTranspositions(word)
	for i=1:1:$LISTLENGTH(transpositions){
		set $LIST(resultList, resultListItemsCount + 1) = $LIST(transpositions,i)
		
		set resultListItemsCount = resultListItemsCount + 1
	}
	
	set alterations = ##class(Spellcheck.Spellchecker).GenerateAlterations(word)
	for i=1:1:$LISTLENGTH(alterations){
		set $LIST(resultList, resultListItemsCount + 1) = $LIST(alterations,i)
		
		set resultListItemsCount = resultListItemsCount + 1
	}
	
	set insertions = ##class(Spellcheck.Spellchecker).GenerateInsertions(word)
	for i=1:1:$LISTLENGTH(insertions){
		set $LIST(resultList, resultListItemsCount + 1) = $LIST(insertions,i)
		
		set resultListItemsCount = resultListItemsCount + 1
	}
	
	return resultList
]]></Implementation>
</Method>

<Method name="GenerateDeletions">
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	set length = $LENGTH(word)
	for i = 1:1:length{
		set $LIST(resultList, i) = $EXTRACT(word, 0, i - 1)_$EXTRACT(word, i + 1, length)
	}
	
	return resultList
]]></Implementation>
</Method>

<Method name="GenerateTranspositions">
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	set length = $LENGTH(word)
	for i = 1:1:length{
		set $LIST(resultList, i) = 
		$EXTRACT(word, 0, i - 1) // beginning of string
		_$EXTRACT(word, i + 1, i + 1) // second letter of swap pair
		_$EXTRACT(word, i, i) // first letter of swap pair
		_$EXTRACT(word, i + 2, length) // end  of string
	}
	
	return resultList
]]></Implementation>
</Method>

<Method name="GenerateAlterations">
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	set length = $LENGTH(word)
	set charsList = $LISTBUILD("а","б","в","г","д","е","ё","ж","з","и","й","к","л","м","н","о","п","р","с","т","у","ф","х","ц","ч","щ","ш","ь","ы","ъ","э","ю","я")
	set charsListLength = $LISTLENGTH(charsList)
	set resultListItemsCount = 0
	
	for i = 1:1:length{
		
		for j=1:1:charsListLength{
			if $LIST(charsList, j) '= $EXTRACT(word, i, i){
				set $LIST(resultList, resultListItemsCount + 1) = 
					$EXTRACT(word, 0, i - 1)
					_$LIST(charsList, j)
					_$EXTRACT(word, i + 1, length)
				
				set resultListItemsCount = resultListItemsCount + 1
			}
					
		}		
	}
	
	return resultList
]]></Implementation>
</Method>

<Method name="GenerateInsertions">
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%Library.List</ReturnType>
<Implementation><![CDATA[
	set length = $LENGTH(word)
	set charsList = $LISTBUILD("а","б","в","г","д","е","ё","ж","з","и","й","к","л","м","н","о","п","р","с","т","у","ф","х","ц","ч","щ","ш","ь","ы","ъ","э","ю","я")
	set charsListLength = $LISTLENGTH(charsList)
	set resultListItemsCount = 0
	
	for i = 1:1:length+1{
		
		for j=1:1:charsListLength{
			if $LIST(charsList, j) '= $EXTRACT(word, i, i){
				set $LIST(resultList, resultListItemsCount + 1) = 
					$EXTRACT(word, 0, i - 1)
					_$LIST(charsList, j)
					_$EXTRACT(word, i, length)
					
				set resultListItemsCount = resultListItemsCount + 1
			}
					
		}		
	}
	
	return resultList
]]></Implementation>
</Method>
</Class>
</Export>
